<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[js中的数据属性和访问器属性]]></title>
    <url>%2F2019%2F10%2F24%2Fjs%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E5%B1%9E%E6%80%A7%E5%92%8C%E8%AE%BF%E9%97%AE%E5%99%A8%E5%B1%9E%E6%80%A7%2F</url>
    <content type="text"><![CDATA[js数据属性和访问器属性 数据属性用来存数据，而访问器属性不能直接存数据，是通过get和set函数来访问设置数据的 数据属性有四种特性： [[Configurable]] [[Enumerable]] [[Writable]] [[Value]]如果想要修改属性默认的特性，可以使用ES5提供的Object.defineProperty()方法，这个方法接收三个参数：属性所在对象、属性的名字和一个描述符对象。描述符对象只能包含上述四个特性的一个或多个。12345678910var person = &#123; name: &quot;Scott&quot;&#125; Object.defineProperty(person,&quot;name&quot;,&#123; writable:false; &#125;) console.log(person.name); //&quot;Scott&quot; person.name = &quot;Evan&quot;; console.log(person.name); //&quot;Scott&quot; 将person对象name属性的特性writable设置为false，此属性的值为不可修改的，因此对该属性的赋值操作会直接忽略。 12345678910111213141516171819202122232425262728var person = &#123; name: &quot;Scott&quot;&#125; Object.defineProperty(person,&quot;name&quot;,&#123; configurable:false&#125;) console.log(person.name) //Scott delete person.name //不可配置，忽略该操作 console.log(person.name) //Scott person.name = &apos;abc&apos; //直接赋值，修改值是没问题的 console.log(person.name) //abc Object.defineProperty(person,&quot;name&quot;,&#123; value:&apos;kkk&apos; &#125;) //用Object.defineProperty修改值是没问题的 console.log(person.name) //kkk Object.defineProperty(person,&quot;name&quot;,&#123; writable:false &#125;) person.name = &apos;ll&apos; console.log(person.name) //writable:false，所以值也改不了了 Object.defineProperty(person,&quot;name&quot;,&#123; writable:true &#125;) //报错//设置configurable为false后，无法delete对象中的属性；不能修改enumerable；虽然不可配置，但修改数据的值是没问题的；如果修改了writable为false，因为configurable为false，所以现在数据的值也改不了了 可以看到，当把name属性的特性值configurable设置为false之后，就表示不能从对象中删除属性。但需要注意的是，当把属性定义为不可配置之后，就不能把它变回可配置的了。此时修改除writable之外的其它特性都会报错，例如： 12345678910var person = &#123; name: &quot;Scott&quot;&#125; Object.defineProperty(person,&quot;name&quot;,&#123; configurable:false; &#125;) Object.defineProperty(person,&quot;name&quot;,&#123; configurable:true; //此处会抛出错误 &#125;) 访问器属性的四个特性： [[Configurable]] [[Enumerable]] [[Get]] [[Set]]访问器属性不能直接定义，必须通过Object.defineProperty()函数定义，例如1234567891011121314151617181920212223242526272829303132333435var person = &#123; _name: &quot;Scott&quot;, _age: 24, _tel: 86247 &#125;; //name属性为只读的 Object.defineProperty(person,&quot;name&quot;,&#123; get: function()&#123; return this._name; &#125; &#125;); //age属性为只写不可读的 Object.defineProperty(person,&quot;age&quot;,&#123; set: function(p)&#123; this._age = p; &#125; &#125;); //tel属性为可读可写的 Object.defineProperty(person,&quot;tel&quot;,&#123; get:function()&#123; return this._tel; &#125;, set: function(p)&#123; this._tel = p; &#125; &#125;); console.log(person.name); //&quot;Scott&quot; person.name = &quot;Evan&quot;; console.log(person.name); //&quot;Scott&quot;，对name属性的修改无效 console.log(person.age); //undefined，不可读属性 person.age = 25; console.log(person._age); //25，已经修改 console.log(person.tel); //&quot;86247&quot;，可读属性 person.tel = &quot;13975&quot;; console.log(person.tel); //&quot;13975&quot;，可以修改 定义多个属性的方法(Properties加了s)： 12345678910111213141516171819202122232425var person = &#123; _name: &quot;Scott&quot;, _age: 24, _tel: 86247 &#125;; Object.defineProperties(person,&#123; name:&#123; get: function()&#123; return this._name; &#125; &#125;, age:&#123; set: function(p)&#123; this._age = p; &#125; &#125;, tel:&#123; get:function()&#123; return this._tel; &#125;, set: function(p)&#123; this._tel = p; &#125; &#125; &#125;); ES5提供了Object.getOwnPropertyDescripter()方法来获取给定属性的描述符。该方法接收两个参数：属性所在的对象和要读取其描述符的属性名称。结果会返回一个对象，如果是访问器属性，返回的对象有configuable、enumerable、get和set；如果是数据属性，这个返回对象的属性包括configuable、enumerable、writable和value。对于上面的例如，使用如下： 1234567891011121314151617181920212223242526272829var person = &#123; _name: &quot;Scott&quot;, _age: 24, _tel: 86247 &#125;; Object.defineProperties(person,&#123; name:&#123; get: function()&#123; return this._name; &#125; &#125;, age:&#123; set: function(p)&#123; this._age = p; &#125; &#125;, tel:&#123; get:function()&#123; return this._tel; &#125;, set: function(p)&#123; this._tel = p; &#125; &#125; &#125;); var descripter = Object.getOwnPropertyDescriptor(person,&quot;tel&quot;); console.log(descripter.value); //undefined console.log(descripter.enumerable); //false console.log(typeof descripter.get); //&quot;function&quot; 参考文章：https://www.jb51.net/article/91698.htmhttps://www.cnblogs.com/absolute-child/p/7188417.html]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP常见问题]]></title>
    <url>%2F2019%2F09%2F26%2FHTTP%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[关于HTTP与HTTPS HTTP 和HTTPS的区别：答：开头；安全；加密；端口号；OSI层级；证书 什么是Http协议无状态协议?怎么解决Http协议无状态协议?答：无法记录状态；解决方法：cookie 常用的HTTP方法有哪些？答：GET，POST，HEAD，PUT，DELETE，OPTIONS，TRACE，CONNECT 请求报文和响应报文格式答： 请求行：请求方法，URL，HTTP协议请求头部空行请求体 响应行：状态码响应头部空行响应体 请求方法的特点 GET：参数长度限制，不舍和私密数据，不适合大量数据，一般请求用GET POST：数据封装在请求报文中，可传递大量数据且没有限制，不会出现在URL中，表单提交用POST HEAD：与GET相似，不过只返回响应头，不返回相应内容，用于查看页面状态（页面是否有更新） OPTIONS：获取当前URL所支持的方法 DELETE:删除某资源 PUT：把一个资源放到指定位置上，与POST相似，不过POST不指定资源存放位置，POST的数据存放位置有服务器自己决定 TRACE：回显服务器收到的请求，主要用于测试或诊断 CONNECT：HTTP/1.1协议预留的，能够将连接改为管道方式的代理服务器，通常用于SSL加密服务器的连接与非加密的HTTP代理服务器的通信 常见的首部： 通用首部字段（请求报文与响应报文都会使用的首部字段）Date：创建报文时间Connection：连接的管理Cache-Control：缓存的控制Transfer-Encoding：报文主体的传输编码方式 请求首部字段（请求报文会使用的首部字段）Host：请求资源所在服务器Accept：可处理的媒体类型Accept-Charset：可接收的字符集Accept-Encoding：可接受的内容编码Accept-Language：可接受的自然语言 响应首部字段（响应报文会使用的首部字段）Accept-Ranges：可接受的字节范围Location：令客户端重新定向到的URIServer：HTTP服务器的安装信息 实体首部字段（请求报文与响应报文的的实体部分使用的首部字段）Allow：资源可支持的HTTP方法Content-Type：实体主类的类型Content-Encoding：实体主体适用的编码方式Content-Language：实体主体的自然语言Content-Length：实体主体的的字节数Content-Range：实体主体的位置范围，一般用于发出部分请求时使用 HTTPS工作原理 客户端请求 服务端返回公钥 客户端检测公钥合法性 生成一个随机值，将随机值用公钥加密传输给服务端 服务端收到后用服务端的私钥进行解密 将待传送的消息与随机值进行对称加密发送给客户端 客户端收到消息后利用随机值进行解密 HTTP1.1特性 持久连接 管线化 断点续传 HTTP优化方案 TCP复用：多个客户端的HTTP请求连接到一个服务端的TCP连接上（负载均衡设备的独特功能）； HTTP复用：一个客户端的多个HTTP请求通过一个TCP连接进行处理（HTTP1.1协议所支持的新功能，目前被大多数浏览器支持） 内容缓存： 压缩 SSL加速 TCP缓冲 参考连接：HTTP面试题都在这里https://www.cnblogs.com/Java3y/p/8444033.htmlhttps工作原理https://blog.csdn.net/sean_cd/article/details/6966130HTTP请求报文和响应报文https://www.jianshu.com/p/0015277c6575]]></content>
      <tags>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[slice,substring,substr的区别]]></title>
    <url>%2F2019%2F09%2F25%2Fslice-substring-substr%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[slice,substring,substr用于数组或字符串之间的截取 slice（开始位置，结束位置）substring（开始位置，结束位置）substr（开始位置，截取几位） slice可以用于数组也可用于字符串 substring和substr只用于字符串 12345678910var arr = [1,2,3,4,5,6,7], str = &quot;helloworld!&quot;; //防止空格干扰，不用带空格的，注意这里有个！号也算一位 console.log(str.slice(1)); //elloworld! console.log(str.substring(1)); //elloworld! console.log(str.substr(1)); //elloworld! console.log(arr.slice(1)); //[2,3,4,5,6,7]console.log(arr.substr(1)); //TypeError: arr.substr is not a functionconsole.log(arr.substring(1)); //TypeError: arr.substring is not a function slice，substr能够将负数位置转换成整数位置 substring能自动调换参数位置，负数当0处理 当第一参（正）＞第二参（正）时 slice返回空 substring 自动调换参数位置 substr（开始位置，取n位） //如果第一参大于str.length，返回空 123456//栗子不变console.log(str.slice(5,1)); //&quot;&quot;console.log(str.substring(5,1)); //elloconsole.log(str.substr(5,1)); //&quot;w&quot; console.log(arr.slice(5,1)); //[] 第一参正，第二参负 slice 将负数位置转化位正数位置后，截取 substring 将负数当成0处理 substr 第二参数为负数时，返回空 1234567//栗子不变//第一参正，第二参负console.log(str.slice(1,-2)); //elloworlconsole.log(str.substr(1,-2)); //&quot;&quot;console.log(str.substring(1,-2)); //h console.log(arr.slice(1,-2)); //[ 2, 3, 4, 5] 第一参负，第二参正 slice 负数位置转化正数位置后截取 substring 把负数当成0处理 substr 负数位置转化正数位置后截取 1234567//第一参负，第二参正//栗子不变console.log(str.slice(-3,1)) //&quot;&quot;console.log(str.substr(-3,1)) //lconsole.log(str.substring(-3,1)) //h console.log(arr.slice(-3,1)) //[] 其他情况依照以上原则判断 1234567891011121314//全负//栗子不变console.log(str.slice(-1,-5)); //&quot;&quot;console.log(str.substr(-1,-5)); //&quot;&quot;console.log(str.substring(-1,-5)); //&quot;&quot; console.log(arr.slice(-1,-5)); //[]//上面的结果全是空 console.log(str.slice(-5,-1)); //orldconsole.log(str.substr(-5,-1)); //&quot;&quot;console.log(str.substring(-5,-1)); //&quot;&quot; console.log(arr.slice(-5,-1)); //[ 3, 4, 5, 6 ] 参考链接：https://blog.csdn.net/qq_38047742/article/details/82144266]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[近期总结]]></title>
    <url>%2F2019%2F09%2F24%2F%E8%BF%91%E6%9C%9F%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[记一次面试 今天去面了一下华资，其实也没聊什么；印象比较深的就是聊到有关前端学习方法的问题；在此先把一些大佬们的建议先记录一下，接下来，还需调整一下自己的状态与方法； 心态方面目前个人心态比较急躁，急于求成；需要自己静下心来，好好将自己所学的东西沉淀一下；对于学习自己要有自己的方向与节奏，切莫激进，只要保证自己正在前进就没问题！ 前端基础对于前端知识基础，现在表现的状态为，过于注重知识的输入量，缺乏知识的内化吸收，导致对知识的掌握只停留在看懂的层面；这个与自己的急躁有一定的关系；自己需要继续尝试画图理解，归纳总结，最主要的是明白其中的原理，分辨哪些是根本，哪些是相关技巧，有针对性，目的性的学习，要注重知识点的内化及清楚正确地表述 编程能力目前编程题目做的很少，一道题给出来并不知道其中考察的是哪些知识点；这点我觉得自己需要反思一下，题目做得确实是太少了；对于算法，我需要多去了解一些常见的算法而不仅仅只是排序；对于常见api，个人这方面也如同前端基础知识那样，只是在做着相关知识的堆积，少了对内化及运用 框架学习对于框架学习不应停留在应用层面，要思考自己相对于其他面试者的优势在哪里；是否熟悉这个公司目前使用的是哪个框架；自己所学习的技术栈是否能跟这家公司进行较好地对接；自己能够为这家公司带来什么价值，公司凭什么要选你；对于这些问题，大佬表示应该先选好一个框架，学习理解该框架的底层原理实现，理解的过程也要注重对框架的使用，以理论与实践相结合来帮助自己透彻地理解其中相关的原理以及达到融会贯通的层次； 个人项目目前就我而言，完全没什么相关项目可以写进简历中，跟着书上的demo以及视频做的案例，个人觉得真的好low。大佬建议，应该尽可能的用自己目前所学习的相关技术栈做一个自己的小项目；一些假电商项目作为一个应届生几乎是写不了的 以上基本上是结合晰铨大佬以及今天的面试官给我的相关建议做的一份总结：下一阶段目标：心态调整稳定，vue框架原理理解，vue项目实操，编程能力，前端基础内化及表述。]]></content>
      <tags>
        <tag>学习方法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[两种循环]]></title>
    <url>%2F2019%2F09%2F23%2F%E4%B8%A4%E7%A7%8D%E5%BE%AA%E7%8E%AF%2F</url>
    <content type="text"><![CDATA[for in 和 for of区别 for in 用于遍历键名（包括原型上的键以及手动添加的键） for of 用于遍历值（需要该对象上有 iterator接口，才能用） 两者比较 123456789101112131415const obj = &#123; a: 1, b: 2, c: 3 &#125; for (let i in obj) &#123; console.log(i) // a // b // c &#125; for (let i of obj) &#123; console.log(i) // Uncaught TypeError: obj is not iterable 报错了 &#125; 12345678910111213141516const arr = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;] // for in 循环 for (let i in arr) &#123; console.log(i) // 0 // 1 // 2 &#125; // for of for (let i of arr) &#123; console.log(i) // a // b // c &#125; 12345678910111213Array.prototype.test = &quot;abc&quot;const arr = [&apos;a&apos;, &apos;b&apos;] // 手动给 arr数组添加一个属性 arr.name = &apos;qiqingfu&apos; // for in 循环可以遍历出 name 这个键名 for (let i in arr) &#123; console.log(i) // 0 // 1 // name //test &#125; for in 的特点for … in 循环返回的值都是数据结构的 键值名。遍历对象返回的对象的key值,遍历数组返回的数组的下标(key)。for … in 循环不仅可以遍历数字键名,还会遍历原型上的值和手动添加的其他键。如——例3特别情况下, for … in 循环会以任意的顺序遍历键名总结一句: for in 循环特别适合遍历对象。 for of 特点for of 循环用来获取一对键值对中的值,而 for in 获取的是 键名一个数据结构只要部署了 Symbol.iterator 属性, 就被视为具有 iterator接口, 就可以使用 for of循环。例1这个对象,没有 Symbol.iterator这个属性,所以使用 for of会报 obj is not iterablefor of 不同与 forEach, 它可以与 break、continue和return 配合使用,也就是说 for of 循环可以随时退出循环。提供了遍历所有数据结构的统一接口 哪些数据结构部署了 Symbol.iteratoer属性了呢?只要有 iterator 接口的数据结构,都可以使用 for of循环。ArrayMapSetStringarguments对象Nodelist对象, 就是获取的dom列表集合以上这些都可以直接使用 for of 循环。 凡是部署了 iterator 接口的数据结构也都可以使用数组的 扩展运算符(…)、和解构赋值等操作。 我也想让对象可以使用 for of循环怎么办?使用 Object.keys() 获取对象的 key值集合后,再使用 for of以例1为例,可以给一个对象部署 Symbol.iterator属性。 123456789101112const obj = &#123; a: 1, b: 2, c: 3&#125;for (let i of Object.keys(obj)) &#123; console.log(i) // 1 // 2 // 3&#125; 参考连接：http://www.fly63.com/article/detial/1444]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Object.create和Object.assign]]></title>
    <url>%2F2019%2F09%2F23%2FObject-create%E5%92%8CObject-assign%2F</url>
    <content type="text"><![CDATA[Object.create和Object.assign的区别： obj1.create(obj2)将obj1的原型指向obj2 obj1 = Object.assign(obj2,obj3,obj4) Object.create() Object.create(proto[, propertiesObject]) 作用 Object.create()方法创建一个新对象，使用现有的对象来提供新创建的对象的proto 常见例子 1234567891011121314const person = &#123; isHuman: false, printIntroduction: function () &#123; console.log(`My name is $&#123;this.name&#125;. Am I human? $&#123;this.isHuman&#125;`); &#125;&#125;;const me = Object.create(person);me.name = &quot;Matthew&quot;; // &quot;name&quot; is a property set on &quot;me&quot;, but not on &quot;person&quot;me.isHuman = true; // inherited properties can be overwrittenme.printIntroduction();// expected output: &quot;My name is Matthew. Am I human? true&quot; 不常用例子 12345678910111213141516o = Object.create(Object.prototype, &#123; // foo会成为所创建对象的数据属性 foo: &#123; writable:true, configurable:true, value: &quot;hello&quot; &#125;, // bar会成为所创建对象的访问器属性 bar: &#123; configurable: false, get: function() &#123; return 10 &#125;, set: function(value) &#123; console.log(&quot;Setting `o.bar` to&quot;, value); &#125; &#125;&#125;); 1234567// 创建一个以另一个空对象为原型,且拥有一个属性p的对象o = Object.create(&#123;&#125;, &#123; p: &#123; value: 42 &#125; &#125;)// 省略了的属性特性默认为false,所以属性p是不可写,不可枚举,不可配置的:o.p = 24o.p//42 123456789//创建一个可写的,可枚举的,可配置的属性po2 = Object.create(&#123;&#125;, &#123; p: &#123; value: 42, writable: true, enumerable: true, configurable: true &#125; &#125;); Object.assign() Object.assign(target, …sources) 用于将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。 常见特性： 相同的键，会被覆盖； String类型和 Symbol 类型的属性都会被拷贝； 在出现错误的情况下，例如，如果属性不可写，会引发TypeError，如果在引发错误之前添加了任何属性，则可以更改target对象； Object.assign 不会在那些source对象值为 null 或 undefined 的时候抛出错误。 常见例子12345678910const target = &#123; a: 1, b: 2 &#125;;const source = &#123; b: 4, c: 5 &#125;;const returnedTarget = Object.assign(target, source);console.log(target);// expected output: Object &#123; a: 1, b: 4, c: 5 &#125;console.log(returnedTarget);// expected output: Object &#123; a: 1, b: 4, c: 5 &#125; 123const obj = &#123; a: 1 &#125;;const copy = Object.assign(&#123;&#125;, obj);console.log(copy); // &#123; a: 1 &#125; 1234567891011121314151617181920212223//对象深拷贝let obj1 = &#123; a: 0 , b: &#123; c: 0&#125;&#125;; let obj2 = Object.assign(&#123;&#125;, obj1); console.log(JSON.stringify(obj2)); // &#123; a: 0, b: &#123; c: 0&#125;&#125; obj1.a = 1; console.log(JSON.stringify(obj1)); // &#123; a: 1, b: &#123; c: 0&#125;&#125; console.log(JSON.stringify(obj2)); // &#123; a: 0, b: &#123; c: 0&#125;&#125; obj2.a = 2; console.log(JSON.stringify(obj1)); // &#123; a: 1, b: &#123; c: 0&#125;&#125; console.log(JSON.stringify(obj2)); // &#123; a: 2, b: &#123; c: 0&#125;&#125; obj2.b.c = 3; console.log(JSON.stringify(obj1)); // &#123; a: 1, b: &#123; c: 3&#125;&#125; console.log(JSON.stringify(obj2)); // &#123; a: 2, b: &#123; c: 3&#125;&#125; // Deep Clone obj1 = &#123; a: 0 , b: &#123; c: 0&#125;&#125;; let obj3 = JSON.parse(JSON.stringify(obj1)); obj1.a = 4; obj1.b.c = 4; console.log(JSON.stringify(obj3)); // &#123; a: 0, b: &#123; c: 0&#125;&#125; 12345678//合并对象const o1 = &#123; a: 1 &#125;;const o2 = &#123; b: 2 &#125;;const o3 = &#123; c: 3 &#125;;const obj = Object.assign(o1, o2, o3);console.log(obj); // &#123; a: 1, b: 2, c: 3 &#125;console.log(o1); // &#123; a: 1, b: 2, c: 3 &#125;, 注意目标对象自身也会改变 1234567//合并具有相同属性的对象const o1 = &#123; a: 1, b: 1, c: 1 &#125;;const o2 = &#123; b: 2, c: 2 &#125;;const o3 = &#123; c: 3 &#125;;const obj = Object.assign(&#123;&#125;, o1, o2, o3);console.log(obj); // &#123; a: 1, b: 2, c: 3 &#125; 1234567//拷贝 symbol 类型的属性const o1 = &#123; a: 1 &#125;;const o2 = &#123; [Symbol(&apos;foo&apos;)]: 2 &#125;;const obj = Object.assign(&#123;&#125;, o1, o2);console.log(obj); // &#123; a : 1, [Symbol(&quot;foo&quot;)]: 2 &#125; (cf. bug 1207182 on Firefox)Object.getOwnPropertySymbols(obj); // [Symbol(foo)] 12345678910111213//继承属性和不可枚举属性是不能拷贝的const obj = Object.create(&#123;foo: 1&#125;, &#123; // foo 是个继承属性。 bar: &#123; value: 2 // bar 是个不可枚举属性。 &#125;, baz: &#123; value: 3, enumerable: true // baz 是个自身可枚举属性。 &#125;&#125;);const copy = Object.assign(&#123;&#125;, obj);console.log(copy); // &#123; baz: 3 &#125; 12345678910//原始类型会被包装为对象const v1 = &quot;abc&quot;;const v2 = true;const v3 = 10;const v4 = Symbol(&quot;foo&quot;)const obj = Object.assign(&#123;&#125;, v1, null, v2, undefined, v3, v4); // 原始类型会被包装，null 和 undefined 会被忽略。// 注意，只有字符串的包装对象才可能有自身可枚举属性。console.log(obj); // &#123; &quot;0&quot;: &quot;a&quot;, &quot;1&quot;: &quot;b&quot;, &quot;2&quot;: &quot;c&quot; &#125; 123456789101112131415//异常会打断后续拷贝任务const target = Object.defineProperty(&#123;&#125;, &quot;foo&quot;, &#123; value: 1, writable: false&#125;); // target 的 foo 属性是个只读属性。Object.assign(target, &#123;bar: 2&#125;, &#123;foo2: 3, foo: 3, foo3: 3&#125;, &#123;baz: 4&#125;);// TypeError: &quot;foo&quot; is read-only// 注意这个异常是在拷贝第二个源对象的第二个属性时发生的。console.log(target.bar); // 2，说明第一个源对象拷贝成功了。console.log(target.foo2); // 3，说明第二个源对象的第一个属性也拷贝成功了。console.log(target.foo); // 1，只读属性不能被覆盖，所以第二个源对象的第二个属性拷贝失败了。console.log(target.foo3); // undefined，异常之后 assign 方法就退出了，第三个属性是不会被拷贝到的。console.log(target.baz); // undefined，第三个源对象更是不会被拷贝到的。 Object.defineProperty()Object.defineProperty(obj, prop, descriptor)参考连接：Object.create:https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/createObject.assign:https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/assign]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数组api]]></title>
    <url>%2F2019%2F09%2F22%2F%E6%95%B0%E7%BB%84api%2F</url>
    <content type="text"><![CDATA[常用方法（4321+221） 4push（） 返回数组的长度pop（） 返回回最后一个元素shift（） 返回第一个元素unshift（） 返回数组长度 3splice（i，n，m） 可以添加或删除；返回删除的元素slice(start,end) 返回切出来的数组，原数组不受影响concat() 返回连接后的新数组； concat与push区别：如果添加一个数组元素，concat是把数组中每项元素拆分后添加，push是直接将数组整体添加 2reverse（） 返回反转后的数组sort（） 改变原数组 1234567let arr = [2,10,6,1,4,22,3] console.log(arr.sort()) // [1, 10, 2, 22, 3, 4, 6] let arr1 = arr.sort((a, b) =&gt;a - b) console.log(arr1) // [1, 2, 3, 4, 6, 10, 22] let arr2 = arr.sort((a, b) =&gt;b-a) console.log(arr2) // [22, 10, 6, 4, 3, 2, 1] console.log(arr) // [22, 10, 6, 4, 3, 2, 1] 1join 1arrayObject.join(separator) 2reduce(callback,initivalValue) 12345678910const array1 = [1, 2, 3, 4];const reducer = (accumulator, currentValue) =&gt; accumulator + currentValue;// 1 + 2 + 3 + 4console.log(array1.reduce(reducer));// expected output: 10// 5 + 1 + 2 + 3 + 4console.log(array1.reduce(reducer, 5));// expected output: 15 reduceRight(callback,initialValue) 12345let arr = [0,1,2,3,4]let arr1 = arr.reduceRight((preValue, curValue) =&gt; preValue + curValue)console.log(arr1) // 10 2arr.indexOf（查找的项，开始查找的索引）1234567891011var beasts = [&apos;ant&apos;, &apos;bison&apos;, &apos;camel&apos;, &apos;duck&apos;, &apos;bison&apos;];console.log(beasts.indexOf(&apos;bison&apos;));// expected output: 1// start from index 2console.log(beasts.indexOf(&apos;bison&apos;, 2));// expected output: 4console.log(beasts.indexOf(&apos;giraffe&apos;));// expected output: -1 arr.lastIndexOf 1234567var animals = [&apos;Dodo&apos;, &apos;Tiger&apos;, &apos;Penguin&apos;, &apos;Dodo&apos;];console.log(animals.lastIndexOf(&apos;Dodo&apos;));// expected output: 3console.log(animals.lastIndexOf(&apos;Tiger&apos;));// expected output: 1 1arr.includes() 判断是否有给定的值123let arr = [1,2,3,4,5]let arr1 = arr.includes(2) console.log(arr1) // ture 其他方法（53222） 5forEach(callback)遍历数组，无返回值； callback参数：value–当前索引值；index–索引；array –原数组；不会修改原数组！不会修改原数组！不会修改原数组！12345678910111213141516171819202122let arr = [1,2,3,4,5]arr.forEach( (value,index,array)=&gt;&#123; console.log(`value:$&#123;value&#125; index:$&#123;index&#125; array:$&#123;array&#125;`) &#125;) // value:1 index:0 array:1,2,3,4,5 // value:2 index:1 array:1,2,3,4,5 // value:3 index:2 array:1,2,3,4,5 // value:4 index:3 array:1,2,3,4,5 // value:5 index:4 array:1,2,3,4,5let arr = [1,2,3,4,5]arr.forEach( (value,index,array)=&gt;&#123; value = value * 2 console.log(`value:$&#123;value&#125; index:$&#123;index&#125; array:$&#123;array&#125;`) &#125;) console.log(arr) // value:2 index:0 array:1,2,3,4,5 // value:4 index:1 array:1,2,3,4,5 // value:6 index:2 array:1,2,3,4,5 // value:8 index:3 array:1,2,3,4,5 // value:10 index:4 array:1,2,3,4,5 // [1, 2, 3, 4, 5] map(callback)遍历数组，返回一个新数组；不改变原数组； 1234567891011121314let arr = [1,2,3,4,5]arr.map( (value,index,array)=&gt;&#123; value = value * 2 console.log(`value:$&#123;value&#125; index:$&#123;index&#125; array:$&#123;array&#125;`)&#125;) console.log(arr)var array1 = [1, 4, 9, 16];// pass a function to mapconst map1 = array1.map(x =&gt; x * 2);console.log(map1);// expected output: Array [2, 8, 18, 32]console.log(array1); //[1, 4, 9, 16] arr.forEach()和arr.map()的区别 1. arr.forEach()是和for循环一样，是代替for。arr.map()是修改数组其中的数据，并返回新的数据。 2. arr.forEach() 没有return arr.map() 有return filter（callback） 12345678910let arr = [1,2,3,4,5]let arr1 = arr.filter( (value, index) =&gt; value &lt; 3)console.log(arr1) // [1, 2]var words = [&apos;spray&apos;, &apos;limit&apos;, &apos;elite&apos;, &apos;exuberant&apos;, &apos;destruction&apos;, &apos;present&apos;];const result = words.filter(word =&gt; word.length &gt; 6);console.log(result);// expected output: Array [&quot;exuberant&quot;, &quot;destruction&quot;, &quot;present&quot;]console.log(words); //[&apos;spray&apos;, &apos;limit&apos;, &apos;elite&apos;, &apos;exuberant&apos;, &apos;destruction&apos;, &apos;present&apos;] every（callback） 1234567891011121314数组元素全部满足条件，返回true let arr = [1,2,3,4,5]let arr1 = arr.every( (value, index) =&gt; value &lt; 3)console.log(arr1) // falselet arr2 = arr.every( (value, index) =&gt; value &lt; 10)console.log(arr2) // true function isBelowThreshold(currentValue) &#123; return currentValue &lt; 40;&#125;var array1 = [1, 30, 39, 29, 10, 13];console.log(array1.every(isBelowThreshold));// expected output: true some（） 1234567891011121314let arr = [1,2,3,4,5]let arr1 = arr.some( (value, index) =&gt; value &lt; 3)console.log(arr1) // truelet arr2 = arr.some( (value, index) =&gt; value &gt; 10)console.log(arr2) // falsevar array = [1, 2, 3, 4, 5];var even = function(element) &#123; // checks whether an element is even return element % 2 === 0;&#125;;console.log(array.some(even));// expected output: true 3arr.keys()12345let arr = [1,2,3,4]let arr2 = arr.keys()for (let key of arr2) &#123; console.log(key); // 0,1,2,3&#125; arr.values() 12345let arr = [1,2,3,4]let arr1 = arr.values()for (let val of arr1) &#123; console.log(val); // 1,2,3,4&#125; arr.entries() 12345let arr = [1,2,3,4]let arr1 = arr.entries()for (let e of arr1) &#123; console.log(e); // [0,1] [1,2] [2,3] [3,4]&#125; 2arr.findIndex(value,index,array)123let arr = [1,2,3,4,5,2,4]let arr1 = arr.findIndex((value, index, array) =&gt;value &gt; 3)console.log(arr1) // 3 arr.find(value,index,array) 123let arr = [1,2,3,4,5,2,4]let arr1 = arr.find((value, index, array) =&gt;value &gt; 2)console.log(arr1) // 3 2Array.from()——es6伪数组转化为数组，只要有length就行1234 let str = &apos;12345&apos;console.log(Array.from(str)) // [&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;]let obj = &#123;0:&apos;a&apos;,1:&apos;b&apos;,length:2&#125;console.log(Array.from(obj)) // [&quot;a&quot;, &quot;b&quot;] Array.of()——es6将一组值转化为数组，类似于声明数组 123456789let str = &apos;11&apos;console.log(Array.of(str)) // [&apos;11&apos;]//等价于console.log(new Array(&apos;11&apos;)) // [&apos;11]//但是new Array()有缺点，就是参数问题引起的重载console.log(new Array(2)) //[empty × 2] 是个空数组console.log(Array.of(2)) // [2] 2arr.fill(target,start,end)使用给定的值填充一个数组，填充完后会该变原来的数组, 会改变原数组； 会改变原数组123456789 let arr = [1,2,3,4,5]let arr1 = arr.fill(5)console.log(arr1) // [5, 5, 5, 5, 5]console.log(arr) // [5, 5, 5, 5, 5]; let arr = [1,2,3,4,5]let arr2 = arr.fill(5,2)console.log(arr2) //[1,2,5,5,5]let arr3 = arr.fill(5,1,3)console.log(arr3) //[1,5,5,5,5] 因为改变了原数组，所以这里不是[1,5,5,4,5] arr.copyWidthin() 参数：target（必选） start（可选） end（可选）；获取start到end间的元素替换掉数组中target开始对应的项; 会改变原来的数组！会改变原来的数组！会改变原来的数组！ 123456789let arr = [1,2,3,4,5,6,7]let arr1 = arr.copyWithin(1)console.log(arr1) // [1, 1, 2, 3, 4, 5, 6]console.log(arr) // [1, 1, 2, 3, 4, 5, 6]let arr2 = arr.copyWithin(1,2)console.log(arr2) // [1, 2, 3, 4, 5, 6, 6]console.log(arr) // [1, 2, 3, 4, 5, 6, 6]let arr3 = arr.copyWithin(1,2,4)console.log(arr3) // [1, 3, 4, 4, 5, 6, 6] 不会修改原数组 1234567concatslicejoinsplittoStringvalueOf迭代方法 会修改原数组 1234567pushpopshiftunshiftreversesortsplice 返回新数组 12concatarr.map(callback) split 将字符串转化为数组参考：https://www.cnblogs.com/sqh17/p/8529401.html]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BFC]]></title>
    <url>%2F2019%2F09%2F21%2FBFC%2F</url>
    <content type="text"><![CDATA[BFC是什么BFC全称是Block Formatting Context，即块格式化上下文。块格式上下文是页面CSS 视觉渲染的一部分，用于决定块盒子的布局及浮动相互影响范围的一个区域。 三种定位 常规流 对于静态定位(static positioning)，position: static，盒的位置是常规流布局里的位置； 对于相对定位(relative positioning)，position: relative，盒偏移位置由这些属性定义top，bottom，leftandright。即使有偏移，仍然保留原有的位置，其它常规流不能占用这个位置。 浮动(Floats) 绝对定位(Absolute positioning)BFC创建的7种方法 根元素或其它包含它的元素； 浮动 (元素的float不为none)； 绝对定位元素 (元素的position为absolute或fixed)； 行内块inline-blocks(元素的 display: inline-block)； 表格单元格(元素的display: table-cell，HTML表格单元格默认属性)； overflow的值不为visible的元素； 弹性盒 flex boxes (元素的display: flex或inline-flex)； 最常见的就是overflow:hidden、float:left/right、position:absolute。也就是说，每次看到这些属性的时候，就代表了该元素以及创建了一个BFC了。BFC的范围一个BFC包含创建该上下文元素的所有子元素，但不包括创建了新BFC的子元素的内部元素。12345678910&lt;div id=&apos;div_1&apos; class=&apos;BFC&apos;&gt; &lt;div id=&apos;div_2&apos;&gt; &lt;div id=&apos;div_3&apos;&gt;&lt;/div&gt; &lt;div id=&apos;div_4&apos;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div id=&apos;div_5&apos; class=&apos;BFC&apos;&gt; &lt;div id=&apos;div_6&apos;&gt;&lt;/div&gt; &lt;div id=&apos;div_7&apos;&gt;&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 这段代码表示，#div_1创建了一个块格式上下文，这个上下文包括了#div_2、#div_3、#div_4、#div_5。即#div_2中的子元素也属于#div_1所创建的BFC。但由于#div_5创建了新的BFC，所以#div_6和#div_7就被排除在外层的BFC之外。从另一方角度说明，一个元素不能同时存在于两个BFC中。 BFC的一个最重要的效果是，让处于BFC内部的元素与外部的元素相互隔离，使内外元素的定位不会相互影响。这是利用BFC清除浮动所利用的特性 BFC的效果 BFC内部可以看作有一个常规流 BFC内部margin collapse 元素的margin box的左边与容器的content box左边想接触 BFC是独立的容器，里面的子元素不会影响外面的元素，外面的元素也不会影响里面的元素 计算BFC高度时，考虑BFC包含的所有元素，连浮动的子元素也包括，但不包括浮动的子元素中的子元素 移动盒区域不添加到BFC上具体实例：https://juejin.im/post/59b73d5bf265da064618731d#heading-12BFC的应用 兄弟元素之间划清界限：overflow:auto 或者 display：flow-root(兼容性差);1234567891011121314151617181920212223 *&#123; padding: 0; margin: 0; &#125; .slide-bar&#123; width: 100px; min-height: 300px; border:5px solid red; float:left; &#125; .main&#123; border:10px solid green; min-height: 300px; overflow: auto; &#125;&lt;div class=&quot;slide-bar&quot;&gt; &lt;/div&gt;&lt;div class=&quot;main&quot;&gt;&lt;/div&gt; 清除浮动123456789101112131415161718192021222324252627 *&#123; padding: 0; margin: 0; &#125; .father&#123; min-height: 10px; border:5px solid red; &#125; .son&#123; background-color:green; width: 300px; height: 100px; float: left;&#125; .clearfix::after&#123; content: &apos;&apos;; display: block; clear: both; &#125;&lt;div class=&quot;father clearfix&quot;&gt; &lt;div class=&quot;son&quot;&gt;&lt;/div&gt;&lt;/div&gt; 竖直方向上margin合并现象1234567891011 *&#123; padding: 0; margin: 0; &#125; .demo1&#123;width: 200px;height: 200px;background-color: red;margin-bottom: 20px;&#125; .demo2&#123;width: 200px;height: 200px;background-color: black;margin-top: 30px;&#125;&lt;div class=&quot;demo1&quot;&gt;&lt;/div&gt;&lt;div class=&quot;demo2&quot;&gt;&lt;/div&gt; 浏览器解析的时候会使外边距叠加在一起，这时候就是遇到了BFC的问题，那么就要通过触发BFC来解决这个问题。 123456789101112 *&#123; padding: 0; margin: 0; &#125; .demo1&#123;width: 200px;height: 200px;background-color: red;margin-bottom: 20px;&#125; .demo2&#123;width: 200px;height: 200px;background-color: black;margin-top: 30px;&#125; .box&#123;position :absolute;&#125;&lt;div class=&quot;demo1&quot;&gt;&lt;/div&gt;&lt;div class=&quot;box&quot;&gt;&lt;div class=&quot;demo2&quot;&gt;&lt;/div&gt; 高度塌陷1234567html&lt;div class=&quot;box&quot;&gt; &lt;div class=&quot;demo&quot;&gt;&lt;/div&gt;&lt;/div&gt;css.box&#123;width: 300px;height: 300px;background-color: black;&#125;.demo&#123;width: 100px;height: 100px;background-color: red;margin: 20px;&#125; 解决： 1234567html&lt;div class=&quot;box&quot;&gt; &lt;div class=&quot;demo&quot;&gt;&lt;/div&gt;&lt;/div&gt;css.box&#123;width: 300px;height: 300px;background-color: black;overflow: hidden;&#125;.demo&#123;width: 100px;height: 100px;background-color: red;margin: 20px;&#125; 参考链接：https://juejin.im/post/59b73d5bf265da064618731d#heading-12https://www.jianshu.com/p/33abfdd57fb8https://www.jianshu.com/p/d94c6b679739https://blog.csdn.net/return_js/article/details/81266131https://blog.csdn.net/jiaojsun/article/details/76408215]]></content>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP常见状态码]]></title>
    <url>%2F2019%2F09%2F20%2FHTTP%E5%B8%B8%E8%A7%81%E7%8A%B6%E6%80%81%E7%A0%81%2F</url>
    <content type="text"><![CDATA[状态码分类表 状态码 类别 原因短语 1xx Informational（信息性状态码） 接受的请求正在处理 2xx Success（成功状态码） 请求正常处理完毕 3xx Redirection（重定向） 需要进行附加操作以完成请求 4xx Client error（客户端错误） 客户端请求出错，服务器无法处理请求 5xx Server Error（服务器错误） 服务器处理请求出错 各类别常见状态码：100——客户必须继续发出请求101——客户要求服务器根据请求转换HTTP协议版本 200——OK：表示从客户端发送给服务器的请求被正常处理并返回；201——已创建 ：请求成功且服务器已创建了新的资源。202——已接受： 服务器已接受了请求，但尚未对其进行处理。203——非授权信息： 服务器已成功处理了请求，但返回了可能来自另一来源的信息。204——No Content：成功处理但无返回内容；205——服务器完成了请求，用户代理必须复位当前已经浏览过的文件206——Patial Content：表示客户端进行了范围请求，并且服务器成功执行了这部分的GET请求，响应报文中包含由Content-Range指定范围的实体内容。 301—— Moved Permanently：永久性重定向，表示请求的资源被分配了新的URL，之后应使用更改的URL； 302 ——Found：临时性重定向，表示请求的资源被分配了新的URL，希望本次访问使用新的URL； 301与302的区别：前者是永久移动，后者是临时移动（之后可能还会更改URL）303 ——See Other：表示请求的资源被分配了新的URL，应使用GET方法定向获取请求的资源； 302与303的区别：后者明确表示客户端应当采用GET方式获取资源304—— 如果客户端发送了一个带条件的GET 请求且该请求已被允许，而文档的内容（自上次访问以来或者根据请求的条件）并没有改变，则服务器应当返回这个304状态码。简单的表达就是：服务端已经执行了GET，但文件未变化。 307——Temporary Redirect：临时重定向，与302有着相同的含义，307会遵照浏览器标准不会从POST变成GET；（不同浏览器可能会出现不同的情况）； 400—— Bad Request：表示请求报文中存在语法错误； 401 ——Unauthorized：未经许可，需要通过HTTP认证； 403 ——Forbidden：服务器理解请求客户端的请求，但是拒绝执行此请求 404 ——Not Found：表示服务器上无法找到请求的资源，除此之外，也可以在服务器拒绝请求但不想给拒绝原因时使用； 500 ——Inter Server Error：表示服务器在执行请求时发生了错误，也有可能是web应用存在的bug或某些临时的错误时；501 Not Implemented 服务器不支持请求的功能，无法完成请求502 Bad Gateway 充当网关或代理的服务器，从远端服务器接收到了一个无效的请求503—— Server Unavailable：表示服务器暂时处于超负载或正在进行停机维护，无法处理请求；504 Gateway Time-out 充当网关或代理的服务器，未及时从远端服务器获取请求505 HTTP Version not supported 服务器不支持请求的HTTP协议的版本，无法完成处理 参考链接：常见HTTP状态码：https://blog.csdn.net/banana960531/article/details/85621865HTTP常见的状态码有哪些？https://blog.csdn.net/qq_31879707/article/details/55505857状态码200、300、400、500序列https://www.cnblogs.com/sdcs/p/8508374.html]]></content>
      <tags>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则表达式]]></title>
    <url>%2F2019%2F09%2F19%2F%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[正则表达式创建方式 字面量 1var regExp = /[a-z]\s/i 构造函数 1var regExp = new RegExp(&apos;[a-z]\\s&apos;,&apos;i&apos;) 特殊字符12345678910111213141516171819202122232425262728293031323334353637383940414243\ 转义字符^ $* 0次或多次+ 1次或多次？ 0次或1次 非贪婪 /e?le?/ 匹配 &quot;angel&quot; 中的 &apos;el&apos;、&quot;angle&quot; 中的 &apos;le&apos; 以及 &quot;oslo&apos; 中的 &apos;l&apos;。. 除换行符外任一字符；当标志符为s时，点号也可以匹配换行符(x) 它会匹配 &apos;x&apos; 并且记住匹配项。其中括号被称为捕获括号。$1,$2,...,x|y&#123;n&#125;&#123;n,&#125;&#123;n,m&#125;[xyz] 中括号中.（点号）和*可以不用转义，转义也没问题[^xyz][\b] 退格\b 使用&quot;moon&quot;举例： /\bm/匹配“moon”中的‘m’； /oo\b/并不匹配&quot;moon&quot;中的&apos;oo&apos;，因为&apos;oo&apos;被一个“字”字符&apos;n&apos;紧跟着。 /oon\b/匹配&quot;moon&quot;中的&apos;oon&apos;，因为&apos;oon&apos;是这个字符串的结束部分。 这样他没有被一个“字”字符紧跟着。 /\w\b\w/将不能匹配任何字符串，因为在一个单词中间的字符 永远也不可能同时满足没有“字”字符跟随和有“字”字符跟随两种情况。\d\D\n 换行\r 回车\s\S\t\v\w\W\1 在正则表达式中，它返回最后的第n个子捕获匹配的子字符串(捕获的数目以左括号计数)。 比如 /apple(,)\sorange\1/ 匹配&quot;apple, orange, cherry, peach.&quot;中的&apos;apple, orange,&apos; 。\0 = null（？：x）如果表达式是 /foo&#123;1,2&#125;/，&#123;1,2&#125; 将只应用于&apos;foo&apos;的最后一个字符&apos;o&apos;。 如果使用非捕获括号，则&#123;1,2&#125; 会应用于整个 &apos;foo&apos; 单词。 x（？=y）（？&lt;= y）xx（？！y）（？&lt;！y）x 与正则对象相关的属性123456789var myRe = /d(b+)d/g;var myArray = myRe.exec(&quot;cdbbdbsbz&quot;); console.log(myRe); // /d(b+)d/gconsole.log(myRe.source); // d(b+)dconsole.log(myRe.lastIndex); //5console.log(myArray); //[&apos;dbbd&apos;,&apos;bb&apos;,index:1,input:&apos;cdbbdbsbz&apos;]//执行后//对象myRe拥有的属性：source lastIndex//对象myArray 拥有的属性：匹配的字符串，子表达式，index input 你可以使用一个正则表达式创建一个没有分配给变量的对象初始化容器。如果你这样做，那么，每一次使用时都好比在使用一个新的正则表达式。因为这个原因，如果你使用这个未分配给一个变量的正则表达式，你将在随后不能访问这个正则表达式的属性。 123456789var myRe = /d(b+)d/g;var myArray = myRe.exec(&quot;cdbbdbsbz&quot;);console.log(&quot;The value of lastIndex is &quot; + myRe.lastIndex); //The value of lastIndex is 5var myArray = /d(b+)d/g.exec(&quot;cdbbdbsbz&quot;);console.log(&quot;The value of lastIndex is &quot; + /d(b+)d/g.lastIndex); //The value of lastIndex is 0 与正则对象相关的方法 正则对象 exec方法：返回一个数组/null 123456789//有g【匹配文本，子表达式，index，input】，RegExpObject.lastIndex会指向下一个匹配的字符的索引；可以反复调用exec来遍历字符串中匹配的文本，当exec找不到时就会返回null，lastIndex = 0；注：若遍历一次后想重新开始遍历，需要lastIndex = 0//没有g【匹配文本，子表达式，index，input】，RegExp的lastIndex = 0//与String.match()的区别就是，无论是否有g都会返回完整细节 test方法：一个在字符串中测试是否匹配的RegExp方法，它返回 true 或 false。 1234var str = &quot;Visit W3School&quot;;var patt1 = new RegExp(&quot;W3School&quot;);var result = patt1.test(str); //true String对象(4种相关方法 ) match: 一个在字符串中执行查找匹配的String方法，它返回一个数组，在未匹配到时会返回 null。 123456789101112131415161718192021//没有子表达式情况//有gvar re = /\w+\s/g;var str = &quot;fee fi fo fum&quot;;var myArray = str.match(re);console.log(myArray); // [&quot;fee &quot;, &quot;fi &quot;, &quot;fo &quot;]//没有gvar re = /\w+\s/;var str = &quot;fee fi fo fum&quot;;var myArray = str.match(re);console.log(myArray); // [&quot;fee &quot;, index: 0, input: &quot;fee fi fo fum&quot;, groups: undefined]//有子表达式情况//有g ：返回所有匹配的字符串；而且没有子表达式，没有input和index属性str.match(/l([\w]+)/g) // str = &quot;Hello world!&quot;结果如下：[&quot;llo&quot;, &quot;ld&quot;]//没有g：【匹配文本，子表达式，index，input】str.match(/w(\w)+/) // str = &quot;Hello world!&quot;结果如下：[&quot;world&quot;, &quot;d&quot;, index: 6, input: &quot;Hello world!&quot;, groups: undefined] search一个在字符串中测试匹配的String方法，它返回匹配到的位置索引，或者在失败时返回-1。search() 方法不执行全局匹配，它将忽略标志 g。它同时忽略 regexp 的 lastIndex 属性，并且总是从字符串的开始进行检索，这意味着它总是返回 stringObject 的第一个匹配的位置。 1234567var str=&quot;Visit W3School!&quot;document.write(str.search(/W3School/)) //6var str=&quot;Visit W3School!&quot;document.write(str.search(/w3school/)) //-1 replace： 一个在字符串中执行查找匹配的String方法，并且使用替换字符串替换掉匹配到的子字符串$1、$2、…、$99 匹配 与 regexp 中的第 1 到第 99 个子表达式相匹配的文本。$&amp; 匹配 与 regexp 相匹配的子串。$` 匹配 位于匹配子串左侧的文本。$’ 匹配 位于匹配子串右侧的文本。$$ 匹配 直接量符号。 123456789101112name = &quot;Doe, John&quot;;name.replace(/(\w+)\s*, \s*(\w+)/, &quot;$2 $1&quot;);name = &apos;aaa bbb ccc&apos;;uw=name.replace(/\b\w+\b/g, function(word)&#123;return word.substring(0,1).toUpperCase()+word.substring(1);&#125;//???name = &apos;&quot;a&quot;, &quot;b&quot;&apos;;name.replace(/&quot;([^&quot;]*)&quot;/g, &quot;&apos;$1&apos;&quot;); ); split ：一个使用正则表达式或者一个固定字符串分隔一个字符串，并将分隔后的子字符串存储到数组中的 String 方法 1&quot;hello&quot;.split(&quot;&quot;, 3) //可返回 [&quot;h&quot;, &quot;e&quot;, &quot;l&quot;] 通过标志进行高级搜索g： 全局搜索 i: 不区分大小写 m: 多行搜索 s： 允许 . 匹配字符串 u： 使用unicode模式匹配 y： 执行“粘性”搜索,匹配从目标字符串的当前位置开始，可以使用y标志。()[]{} 记忆括号 []表示字符集[abc]匹配a或b或c {} {n,m}参考链接：MDN：https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions JavaScript exec() 方法https://www.w3school.com.cn/js/jsref_exec_regexp.aspJavaScript match() 方法https://www.w3school.com.cn/js/jsref_match.aspJavaScript test() 方法https://www.w3school.com.cn/js/jsref_test_regexp.aspJavaScript search() 方法https://www.w3school.com.cn/jsref/jsref_search.aspJavaScript split() 方法https://www.w3school.com.cn/js/jsref_split.aspJavaScript replace() 方法https://www.w3school.com.cn/jsref/jsref_replace.asp 正则表达式(括号)、[中括号]、{大括号}的区别小结https://blog.csdn.net/u010552788/article/details/51019367/]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[三种方式创建函数及构造函数与普通函数之间的区别]]></title>
    <url>%2F2019%2F09%2F15%2F%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F%E5%88%9B%E5%BB%BA%E5%87%BD%E6%95%B0%E5%8F%8A%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%8E%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[创建函数的三种方式：函数声明，函数表达式，函数对象 函数声明 1234function sum1(num1,num2)&#123; return num1+num2;&#125;sum1(10,20); 函数表达式 1234var sum2 = function(num1,num2)&#123; return num1+num2;&#125;sum(10,20); 函数对象形式 123456var sum3 = new Function(&quot;num1&quot;,&quot;num2&quot;,&quot;return num1+num2&quot;); //var 函数名 = new Function(“参数...”,”函数体”); var sum = new Function(&quot;num1,num2&quot;,&quot;return num1+num2&quot;); var result1 = sum(120,130); alert(result1) 构造函数和普通函数的区别 定义方式：构造函数首字母通常大写 调用方式：构造函数调用方法为：new Person() 普通函数调用方法为：person（） 作用：构造函数用来新建实例对象 构造函数的函数名与类名相同：Person( ) 这个构造函数，Person 既是函数名，也是这个对象的类名 构造函数内部用this 来构造属性和方法 12345678910 function Person(name,job,age)&#123; this.name=name; this.job=job; this.age=age; this.sayHi=function() &#123; alert(&quot;Hi&quot;) &#125; &#125; 构造函数的执行流程 在堆内存中创建一个新的对象 将this指向这个新建的对象 执行函数中的代码 将新建对象作为返回值 构造函数默认将新建对象返回，普通函数如果没定义返回值，则返回undefined 用instanceof 可以检查一个对象是否是一个类的实例，是则返回true；所有对象都是Object对象的后代，所以任何对象和Object做instanceof都会返回true 1234567function Person(name, age, gender)&#123; this.name = name; this.age = age;&#125; var per = new Person(&quot;komal&quot;,20);console.log(per); //Personconsole.log(per instanceof Person) //true 参考博文：https://blog.csdn.net/JinPingQ/article/details/84335179https://blog.csdn.net/weixin_41796631/article/details/82939585]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js数据类型转换及数据类型判断]]></title>
    <url>%2F2019%2F09%2F11%2Fjs%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E5%8F%8A%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%88%A4%E6%96%AD%2F</url>
    <content type="text"><![CDATA[数据类型js的数据类型有七种，其中有六种基本类型：null，undefined，boolean，string，number，symbol；以及一种引用类型：object 数据类型的转换显式转换一. 将非数值转换为数值类型的函数 ：Number(); parseInt(), parseFloat()Number() 函数转换规则： boolean：true转换为1，false转换为0 number：原样输出 undefined：输出NaN null：输出0 字符串：字符串中只包含数字（可带正负号，可为整数或小数）：转为带正负号的十进的整数或小数，且忽略前导0； 字符串为十六进制，转为十进制； 空字符串：0； 其他：NaN 对象：如果是对象，则调用对象的valueOf()方法，然后依照前面的规则转换返回的值。如果转换的结果是NaN，则调用对象的toString()方法，然后再次按照前面的规则转换返回的字符串值 parseInt(string [,radix]) parseInt不遵循四舍五入，radix的取值可为2-32 对于非字符串类型，先转换为字符串 从左向右遍历字符串，直到碰到非数字字符进行“截断”；如果第一个字符就是非数字字符，转换为NaN 123456789var num = [&quot;123&quot; , &quot;124.4&quot; , &quot;234asd&quot; , &quot;asf456&quot;] ; for (i = 0; i &lt; num.length; i++) &#123; console.log(parseInt(num[i])); &#125; //123 ， 124 ， 234 ， NaN parseInt(&apos;&apos;) //NaNparseInt(null) //NaNparseInt(undefined) //NaN 二. 将其它类型的数据转换为字符串类型的函数2.1 String(mix)：将mix转换成字符串类型。该函数可以将任何数据类型的值转换为字符串。2.2 toString(): num.toString([radix]) ：可以将数值（或其他除null，undefined外的数据类型）转换为字符类型，radix可选； 例：把一个二进制的数10001000转换成十六进制的数。 12var num1 = parseInt(&apos;10001000&apos;,2); //136var num2 = num1.toString(16); //&apos;88&apos; 三. 将值转换成布尔值类型：Boolean（）只有这七个值会返回false：undefined, null, -0, +0, NaN, ‘’(空字符), false; 其他情况都会返回true 123456789Boolean(1) ;//返回trueBoolean(&quot;0&quot;);//返回trueBoolean(&quot;abc&quot;);//返回trueBoolean([]); // trueBoolean(&#123;&#125;); // trueBoolean(new Boolean(false))// trueBoolean(false);//返回falseBoolean(&apos;&apos;);//返回falseBoolean(0);//返回false 隐式转换这里说的隐性类型转换，是==引起的转换。 如果存在NaN，一律返回false再看有没有布尔，有布尔就将布尔转换为数字接着看有没有字符串, 有三种情况，对方是对象，对象使用toString进行转换；对方是数字，字符串转数字；对方是字符串，直接比较；其他返回false如果是数字，对方是对象，对象取valueOf进行比较, 其他一律返回falsenull, undefined不会进行类型转换, 但它们俩相等这个顺序一定要死记，这是面试时经常问到的。 1234560 == []; // true, 0 == [].toString(); ---&gt; 0 == 0;&apos;0&apos; == []; // false, &apos;0&apos; == [].toString(); ---&gt; &apos;0&apos; == &apos;&apos;;2 == [&apos;2&apos;]; // true, 2 == [&apos;2&apos;].valueOf(); ---&gt; 2 == &apos;2&apos; ---&gt; 2 == 2;&apos;2&apos; == [2]; // true, &apos;2&apos; == [2].toString(); ---&gt; &apos;2&apos; ==&apos;2&apos;; [] == ![]; //true, [].valueOf() == !Boolean([]) -&gt; 0 == false ---&gt; 0 == 0; 1234567891011121314151617181920212223242526272829303132333435360 == undefined //false1 == true //true2 == &#123;valueOf: function()&#123;return 2&#125;&#125; //trueNaN == NaN //false 8 == undefined //false1 == undefined //false null == &#123;toString: function()&#123;return 2&#125;&#125; //false 0 == null //false null == 1 //false 1 == &#123; toString:function()&#123; return 1 &#125; , valueOf:function()&#123; return [] &#125;&#125; //true//typeof(null) &quot;object&quot;//typeof(undefined) &quot;undefined&quot;//undefined和null在进行相等判断时不进行类型转换//null&gt;0属于关系运算符，不属于相等运算符，null会被当成对象，然后转为0，再进行判断//undefined相等判断时不发生类型转换，判断大于小于时也不发生类型转换 console.log(undefined == undefined); //true console.log(undefined == 0); //false console.log(undefined &gt;= 0); //false console.log(undefined &gt; 0); //false console.log(undefined &lt; 0); //false //null相等判断时不发生类型转换，判断大于小于时会发生类型转换 console.log(null == null); //true console.log(null &gt;= 0); //true console.log(null == 0); //false console.log(null &gt; 0); //false console.log(null &lt; 0); //false console.log(undefined == null); //true //注意： console.log(null &gt;= 0); //true console.log(undefined &gt;= 0); //false 隐式转换为字符 +””(无论是空字符串还是其他字符串，任何数据类型加字符串都变成字符串)12345678910111213141516171819var a;var b = a + &quot;&quot;;console.log(typeof b + &quot; &quot; + b);a = null;b = a + &quot;&quot;;console.log(typeof b + &quot; &quot; + b);a = 123;b = a + &quot;&quot;;console.log(typeof b + &quot; &quot; + b);a = true;b = a + &quot;&quot;;console.log(typeof b + &quot; &quot; + b);11+&apos;11&apos; //&apos;1111&apos;null+&quot;3&quot; //&quot;null3&quot; 隐式转换为数值1234+‘3’ // 3 注意与null+&apos;3&apos;的区别！+ture //1‘10’-20 // -1010-‘one’ // NaN 隐式转换为boolean!!num 相当于调用 Boolean(num) 关于null == 0要比较相等性之前，不能将null和undefined转换成其他任何值。就是undefined和null与其他数在进行相等判断时不进行类型转换。null == undefined,这个是true null&gt;0 //null转化为number，为0，所以0&gt;0结果为false。null&gt;=0 //null转化为number，为0&gt;=0，所以结果为true。null==0// null在做相等判断时，不进行转型，所以null和0为不同类型数据，结果为false 关于NaNNaN属于number类型,NaN与任何值都不相等方法 parseInt() 和 parseFloat() 在不能解析指定的字符串时就返回这个值。 12typeof(NaN) //numberNaN === NaN //false 注意Number.isNaN()和isNaN的区别: 12345678910console.log(Number.isNaN(NaN)); // trueconsole.log(Number.isNaN(Math.sqrt(-2))); // trueconsole.log(Number.isNaN(&apos;hello&apos;)); // falseconsole.log(Number.isNaN([&apos;x&apos;])); // falseconsole.log(Number.isNaN(&#123;&#125;)); // falseconsole.log(isNaN(&apos;hello&apos;)); // trueconsole.log(isNaN([&apos;x&apos;])); // trueconsole.log(isNaN(&#123;&#125;)); // true 数据类型判断的四种方法 typeof typeof的返回值有6种：“number”、”string”、”boolean”、”object”、”function”、”undefined” typeof对于基本数据类型判断是没有问题的，但是遇到引用数据类型（如：Array）是不起作用的，返回object 1typeof [] ; //object instanceofinstanceof 是用来判断 A 是否为 B 的实例，表达式为：A instanceof B，如果 A 是 B 的实例，则返回 true,否则返回 false。 在这里需要特别注意的是：instanceof 检测的是原型，我们用一段伪代码来模拟其内部执行过程： 123456789instanceof (A,B) = &#123; var L = A.__proto__; var R = B.prototype; if(L === R) &#123; // A的内部属性 __proto__ 指向 B 的原型对象 return true; &#125; return false;&#125; 从上述过程可以看出，当 A 的 proto 指向 B 的 prototype 时，就认为 A 就是 B 的实例，我们再来看几个例子 12345678910[] instanceof Array; // true&#123;&#125; instanceof Object;// truenew Date() instanceof Date;// true function Person()&#123;&#125;;new Person() instanceof Person; [] instanceof Object; // truenew Date() instanceof Object;// truenew Person instanceof Object;// true instanceof 只能用来判断两个对象是否属于实例关系， 而不能判断一个对象实例具体属于哪种类型。 instanceof 操作符的问题在于，它假定只有一个全局执行环境。如果网页中包含多个框架，那实际上就存在两个以上不同的全局执行环境，从而存在两个以上不同版本的构造函数。如果你从一个框架向另一个框架传入一个数组，那么传入的数组与在第二个框架中原生创建的数组分别具有各自不同的构造函数。 12345var iframe = document.createElement(&apos;iframe&apos;);document.body.appendChild(iframe);xArray = window.frames[0].Array;var arr = new xArray(1,2,3); // [1,2,3]arr instanceof Array; // false 针对数组的这个问题，ES5 提供了 Array.isArray() 方法 。该方法用以确认某个对象本身是否为 Array 类型，而不区分该对象在哪个环境中创建。 注意： 1234567console.log(&quot;1&quot; instanceof String); //falseconsole.log(1 instanceof Number); //falseconsole.log(true instanceof Boolean); //falsenew Number(1) instanceof Number; //truenew String(&apos;1&apos;) instanceof Number; //truenew Boolean(false) instanceof Number; //true constructor 函数的 constructor 是不稳定的，这个主要体现在自定义对象上，当开发者重写 prototype 后，原有的 constructor 引用会丢失，constructor 会默认为 Object 1234567function Fn()&#123;&#125;;Fn.prototype=new Array();var f=new Fn();console.log(f.constructor===Fn); //falseconsole.log(f.constructor===Array); //true null 和 undefined 是无效的对象，因此是不会有 constructor 存在的，这两种类型的数据需要通过其他方式来判断。 Object.prototype.toString.call(true)12345678910111213Object.prototype.toString.call(&apos;&apos;) ; // [object String]Object.prototype.toString.call(1) ; // [object Number]Object.prototype.toString.call(true) ; // [object Boolean]Object.prototype.toString.call(Symbol()); //[object Symbol]Object.prototype.toString.call(undefined) ; // [object Undefined]Object.prototype.toString.call(null) ; // [object Null]Object.prototype.toString.call(new Function()) ; // [object Function]Object.prototype.toString.call(new Date()) ; // [object Date]Object.prototype.toString.call([]) ; // [object Array]Object.prototype.toString.call(new RegExp()) ; // [object RegExp]Object.prototype.toString.call(new Error()) ; // [object Error]Object.prototype.toString.call(document) ; // [object HTMLDocument]Object.prototype.toString.call(window) ; //[object global] window 是全局对象 global 的引用 参考链接 数据类型转换 https://www.jb51.net/article/136520.htm https://www.jb51.net/article/136521.htm https://blog.csdn.net/qq2071114140/article/details/92478526 https://blog.csdn.net/luckydie/article/details/77948097 https://blog.csdn.net/Doulvme/article/details/83104683 判断数据类型 https://www.cnblogs.com/onepixel/p/5126046.html https://www.cnblogs.com/zt123123/p/7623409.html]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript实现排序算法]]></title>
    <url>%2F2019%2F09%2F10%2FJavaScript%E5%AE%9E%E7%8E%B0%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[实现了冒泡，选择，插入，快排，希尔，归并 冒泡排序123456789101112131415161718192021//外层遍历：len-1&gt;=i&gt;0; i--//内层遍历：0&lt;=j&lt;i; j++//定义一个flag做代码优化function bubbleSort(arr)&#123; var len = arr.length; var tmp; for(var i=len-1; i&gt;0; i++)&#123; var flag = true; for(var j=0; j&lt;i; j++)&#123; if(arr[j]&gt;arr[j+1])&#123; tmp = arr[j]; arr[j] = arr[j+1]; arr[j+1] = tmp; flag = false; &#125; &#125; if(flag)&#123; return arr; &#125; &#125;&#125; 选择排序12345678910111213141516171819202122232425262728293031323334//外层排序：1&lt;=i&lt;len; i++;//内层排序：i+1&lt;=j&lt;len; j++//左边默认有序，在右边找出最小的值与有序中的最大值交换//先定义一个用于交换的变量//外层：0&lt;=i&lt;length-1//假设下一个最小值的下标为i：minIndex//内层：i+1&lt;=j&lt;len//获取最小值下标为minIndex//比较minIndex和i//是否替换//返回arrfunction selectSort(arr)&#123; var len = arr.length; var minIndex, temp; for(var i=0; i&lt;len-1; i++)&#123; minIndex = i; for(var j=i+1; j&lt;len; j++)&#123; //找出右边的最小值 if(arr[j]&lt;arr[minIndex])&#123; minIndex = j; &#125; &#125; if(minIndex !== i)&#123; temp = arr[i]; arr[i] = arr[minIndex]; arr[minIndex] = temp; &#125; &#125; return arr;&#125; 插入排序12345678910111213141516171819202122232425//外层循环：1&lt;=i&lt;len; i++;//内层循环：记录arr[i],当左边默认排好序的数组中的数比arr[i]大时，将它们左移//扑克牌插入//外层：1&lt;=i&lt;len;//用j记录当前的i//用tmp记录当前的arr[i]//当j&gt;0 且 arr[j-1] &gt;tmp//右移//arr[j] = tmp;//return arr;function insertSort(arr)&#123; var len = arr.length; if(len&lt;=1) return arr; for(var i=1; i&lt;len; i++)&#123; var j = i; var temp = arr[i]; while(j&gt;0 &amp;&amp; arr[j-1]&gt;temp)&#123; arr[j] = arr[j-1]; --j; &#125; arr[j] = temp; &#125; return arr;&#125; 快速排序12345678910111213141516171819202122//注意：需要加上if(arr.length &lt;=1) return arr;//否则会导致栈溢出//取数组的中间值arr[num]，将小于arr[num]的分为一个小数组，大于arr[num]的分为一个大数组，递归去做function quickSort(arr)&#123; if(arr.length &lt;= 1) return arr; var num = Math.floor(arr.length/2); var numValue = arr.splice(num,1); var left = []; var right = []; //此处判断条件为i&lt;arr.length;不能是i&lt;len;因为前面已经进行过splice操作，此时的len与arr.length并不相等 for(var i=0; i&lt;arr.length; i++)&#123; if(arr[i]&lt;numValue)&#123; left.push(arr[i]) &#125;else&#123; right.push(arr[i]) &#125; &#125; return quickSort(left).concat(numValue,quickSort(right))&#125; 希尔排序123456789101112131415161718192021222324252627282930function shellSort(arr)&#123; // 1.获取数组的长度 var length = arr.length // 2.根据长度计算增量 var gap = Math.floor(length / 2) // 3.增量不断变量小, 大于0就继续排序 while (gap &gt; 0) &#123; // 4.实现插入排序 for (var i = gap; i &lt; length; i++) &#123; // 4.1.保存临时变量 var j = i var temp = arr[i] // 4.2.插入排序的内层循环 while (j-gap&gt;=0 &amp;&amp; arr[j - gap] &gt; temp) &#123; arr[j] = arr[j - gap] j -= gap &#125; // 4.3.将选出的j位置设置为temp arr[j] = temp &#125; // 5.重新计算新的间隔 gap = Math.floor(gap / 2) &#125; return arr;&#125; 归并排序123456789101112131415161718192021222324252627282930313233343536//归并排序//分治法//先将一个数组分为左右两个数组 //取到数组的中间值，把数组左边划分为一个左数组，数组右边划分为一个右数组，比较两个数组中第一个值，将最小的添加到result中 function mergeSort(arr)&#123; var len = arr.length; if(len&lt;2) return arr; var middle = Math.floor(len/2); var left = arr.slice(0,middle); var right = arr.slice(middle); return merge(mergeSort(left),mergeSort(right));&#125;//将左右两个数组排序后以result返回function merge(left,right)&#123; var result = []; while(left.length&gt;0 &amp;&amp; right.length&gt;0)&#123; if(left[0]&lt;=right[0])&#123; result.push(left.shift()); &#125;else&#123; result.push(right.shift()); &#125; &#125; while(left.length)&#123; result.push(left.shift()); &#125; while(right.length)&#123; result.push(right.shift()); &#125; return result;&#125;]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[事件监听和事件绑定]]></title>
    <url>%2F2019%2F09%2F10%2F%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC%E5%92%8C%E4%BA%8B%E4%BB%B6%E7%BB%91%E5%AE%9A%2F</url>
    <content type="text"><![CDATA[事件监听addEventListener 和 attachEvent区别 addEventListener，removeEventListener是DOM2级事件定义的方法； addEventListener有三个参数：事件类型，执行函数，是否捕获；addEventListener可以实现同一个元素绑定多个click事件，当条件触发时，会依次执行相应的函数 例如 12345 //element.addEventListener(type,listener,useCapture);btn1Obj.addEventListener(&quot;click&quot;,method1,false);btn1Obj.addEventListener(&quot;click&quot;,method2,false);btn1Obj.addEventListener(&quot;click&quot;,method3,false);//执行顺序为method1-&gt;method2-&gt;method3 attachEvent 和detachEvent是IE7，8可用的方法；attachEvent接受两个参数：类型（要加上on），和执行函数；这两个方法支持冒泡阶段执行；当同一个元素也可以绑定多个click事件时，执行顺序与addEventListener的执行顺序相反； 12345btn1Obj.attachEvent(&quot;onclick&quot;,method1);btn1Obj.attachEvent(&quot;onclick&quot;,method2);btn1Obj.attachEvent(&quot;onclick&quot;,method3);//使用格式是前面是事件类型,注意的是需要加on,比如onclick,onsubmit,onchange,执行顺序是//method3-&gt;method2-&gt;method1 兼容性写法12345678910function myAddEvent(obj, ev, fn,useCapture) //obj为要绑定事件的元素，ev为要绑定的事件，fn为绑定事件的函数,userCapture为是否在捕获阶段执行 &#123; var useCapture = useCapture || false; if(obj.attachEvent) &#123; obj.attachEvent(&quot;on&quot; + ev, fn); &#125; else &#123; obj.addEventListener(ev, fn, useCapture); &#125; &#125; 事件绑定三种事件绑定方式 DOM结构中调用 1234 &lt;button id=&quot;btn&quot; onclick =&quot;demo()&quot;&gt;click&lt;/button&gt;function demo()&#123; alert(3) &#125; addEventListener调用123&lt;button id=&quot;btn&quot;&gt;click&lt;/button&gt;var btn = document.getElementById(&apos;btn&apos;);btn.addEventListener(&apos;click&apos;,function()&#123;alert(2)&#125;,false); onclik调用123&lt;button id=&quot;btn&quot;&gt;click&lt;/button&gt; var btn = document.getElementById(&apos;btn&apos;); btn.onclick = function()&#123;alert(1)&#125;; click() 和 onclick() 123//下面两种方法效果是一样的 document.getElementById(&quot;target&quot;).onclick(); document.getElementById(&quot;target&quot;).click(); btnObj.click()是真正地用程序去点击按钮，触发了按钮的onclick事件 btnObj.onclick()只是简单地调用了btnObj的onclick所指向的方法，只是调用方法而已，并未触发事件 onclick绑定多个事件会覆盖在DOM结构如果绑定两个 “onclick” 事件，则只会执行第一个；用 “addeventlistener” 可以绑定多次同一个事件，且都会执行，用btn.onclick = fun()的只会执行最后一个事件。 1234567891011121314151617181920212223242526272829303132331. &lt;div id=&quot;btn&quot; onclick=&quot;clickone()&quot; onclick=&quot;clicktwo()&quot;&gt;&lt;/div&gt; &lt;script&gt; function clickone()&#123; alert(&quot;hello&quot;); &#125; //执行这个 function clicktwo()&#123; alert(&quot;world!&quot;); &#125; &lt;/script&gt; 2. &lt;div id=&quot;btn&quot;&gt;&lt;/div&gt; &lt;script&gt; document.getElementById(&quot;btn&quot;).onclick = function（）&#123; alert(&quot;hello&quot;); &#125; document.getElementById(&quot;btn&quot;).onclick = function（）&#123; alert(&quot;world&quot;); &#125; //执行这个 &lt;/script&gt; 3. &lt;div id=&quot;btn&quot;&gt;&lt;/div&gt; &lt;script&gt; document.getElementById(&quot;btn&quot;).addeventlistener(&quot;click&quot;,clickone,false); function clickone()&#123; alert(&quot;hello&quot;); &#125; //先执行 document.getElementById(&quot;btn&quot;).addeventlistener(&quot;click&quot;,clicktwo,false); function clicktwo()&#123; alert(&quot;world&quot;); &#125; //后执行 &lt;/script&gt; 参考博文： https://www.jianshu.com/p/4af0476a08c9 https://blog.csdn.net/longzhoufeng/article/details/80689150 https://blog.csdn.net/andrewniu/article/details/81102114 https://blog.csdn.net/ion_l/article/details/82662126]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浏览器内核]]></title>
    <url>%2F2019%2F09%2F07%2F%E6%B5%8F%E8%A7%88%E5%99%A8%E5%86%85%E6%A0%B8%2F</url>
    <content type="text"><![CDATA[浏览器内核分为两部分： 一是渲染引擎，其主要负责结构与样式，即网页的内容（HTML，XML，图像等），以及计算网页显示方式，然后输出到打印机；而JS引擎主要是负责解析JavaScript，实现页面交互效果；一个负责搭建静态结构，一个用来展现动态效果；后来js引擎越来越独立，浏览器内核便更加倾向于指渲染引擎。 目前常见浏览器及其内核IE浏览器：ie11之前用Trident内核，后来的Edge采用了新内核（EdgeHTML）火狐浏览器：使用Gecko内核（开源）Safari：使用Webkit内核；而且Webkit最先是由苹果开发的Chrome浏览器：Chrome内核➡Webkit内核➡Blink内核；另外谷歌后来还研发了自己的JavaScript引擎：V8，极大地提高了JavaScript运行速度Opera：最初是自己研发的Presto，后来同谷歌一样用了Webkit，现在也是Blink内核国内浏览器大多数是双核模式：标准模式下为chrome内核，兼容模式下为IE内核 浏览器渲染引擎的工作原理先了解一下浏览器的主要组成部分：用户界面，浏览器引擎，渲染引擎，网络请求模块，JS引擎，用户界面后端，数据层。各部分的作用为：用户界面：包括如地址栏，书签栏等内容构成了浏览器的用户界面，用来实现与用户之间的交互浏览器引擎：用于在渲染引擎和用户界面之间传递命令渲染引擎：当获取到请求的页面资源后，浏览器先解析HTML文档构建“结构树”，然后解析CSS文件，为“结构树”添加样式形成”渲染树“，接下来就是布局过程，为“渲染树”分配屏幕的位置坐标，最后进入绘制阶段，利用UI后端绘制出“渲染树”的每一个节点；另外，为了更好用户体验，浏览器引擎不会等到所有html解析完成后再去构建和布局render树。它是完成解析完一部分内容就显示一部分内容，于此同时还可能通过网络下载相关内容网络请求模块：实现网络请求以及数据接收JS引擎：负责解析JS代码UI后端：负责绘制基本的部件，在底层与操作系统进行交互数据存储：负责存储数据 浏览器页面渲染过程（及尽量避免重绘回流的操作） 用户输入网址（假设是HTML页面，第一次访问，无缓存） 浏览器向服务器发出HTTP请求，服务器返回HTML文件（善用缓存，减少HTTP请求，减轻服务器压力） 浏览器载入HTML代码，获取CSS文件（CSS文件合并，减少HTTP请求） 载入&lt;body&gt;，开始渲染页面（CSS文件放在最上面，避免重复渲染 ） 浏览器发现一个&lt;img&gt;，向服务器发出请求，此时浏览器不会等到图片下载完，而是继续渲染后面的代码（图片文件合并，减少HTTP请求） 服务器返回图片文件，由于图片面积，影响界面中其他元素的排版，此时，浏览器需要重新渲染这部分代码（最好图片都设置尺寸，避免重新渲染） 浏览器发现一个包含js代码的&lt;script&gt;标签，会立即运行该js代码（script最好放在页面最下面） js执行命令：隐藏掉代码中某个div元素，此时浏览器不得不重新渲染这部分代码（页面初始化样式不要使用js控制） 如果某时刻，用户通过点击某个按钮修个这个页面样式（如换肤），请求新的CSS文件，此时发生回流，重新渲染页面 关于reflow和repaintreflow：某个样式发生改变影响页面的布局，发生回流；reflow几乎无法避免，如树目录的折叠展开效果都会引起reflowrepaint：改变某个元素的背景色，文字或边框颜色等不影响布局的属性，成为repaint；reflow的成本比repaint高； 引起reflow的情况（标准流内的元素发生形态上的改变） 改变窗囗大小 改变文字大小 内容的改变，如用户在输入框中敲字 添加/删除样式表 激活伪类，如:hover (IE里是一个兄弟结点的伪类被激活) 操作class属性 脚本操作DOM 计算offsetWidth和offsetHeight 设置style属性reflow是不可避免的，只能将reflow对性能的影响减到最小。 尽可能限制reflow的影响范围。需要改变元素的样式，不要通过父级元素影响子元素。最好直接加在子元素上。 通过设置style属性改变结点样式的话，每设置一次都会导致一次reflow。所以最好通过设置class的方式。 实现元素的动画，它的position属性应当设为fixed或absolute，这样不会影响其它元素的布局。 权衡速度的平滑。比如实现一个动画，以1个像素为单位移动这样最平滑，但reflow就会过于频繁，CPU很快就会被完全占用。如果以3个像素为单位移动就会好很多。 不要用tables布局的另一个原因就是tables中某个元素一旦触发reflow就会导致table里所有的其它元素reflow。在适合用table的场合，可以设置table-layout为auto或fixed，这样可以让table一行一行的渲染，这种做法也是为了限制reflow的影响范围。 很多情况下都会触发reflow，如果css里有expression，每次都会重新计算一遍。 减少不必要的 DOM 层级（DOM depth）。改变 DOM 树中的一级会导致所有层级的改变，上至根部，下至被改变节点的子节点。这导致大量时间耗费在执行 reflow 上面。 避免不必要的复杂的 CSS 选择器，尤其是后代选择器（descendant selectors），因为为了匹配选择器将耗费更多的 CPU 从输入url到加载完成过程]]></content>
      <tags>
        <tag>浏览器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo主题修改]]></title>
    <url>%2F2019%2F09%2F06%2Fhexo%E4%B8%BB%E9%A2%98%E4%BF%AE%E6%94%B9%2F</url>
    <content type="text"><![CDATA[修改Hexo主题及问题记录 昨晚试着将段时间搭建的hexo改一下主题，觉得NexT.Mist看起来挺简洁，挺喜欢这种风格的； 以下主要是一个索引，记录我搭建以及修改过程所参考的文章搭建博客 当时搭建博客主要参考的博文有： Hexo官方文档 hexo史上最全搭建教程 NexT.Mist主题参考的博文： next官方文档 Hexo的Next主题详细配置 修改主题过程遇到的一些小失误 hexo new page tag 创建标签页时报错： FATAL can not read a block mapping entry; a multiline key may not be an implicit key at line 70, column 1: … 错误 解决办法：_config.yml中配置项的冒号后面要用空格隔开，再跟内容 将Hexo设置首页不显示全文 方法：在主题配置文件_config.yml中找到auto_excerpt字段，将enable修改为true，可以实现首页显示文章预览；不过这 并不是Hexo推荐的方法；Hexo推荐在文章中使用&lt;!-- more --&gt;在more之前的内容会显现在首页的文章预览中，而more之后的内容可以在文章详情中显示 Hexo瞎折腾系列(4) - 站点首页不显示文章全文 中文乱码问题：将_config.yml的格式保存为UTF-8 hexo,部署博客到github和coding上，代码put上去了，但是访问博客内容却没更新？ 解决方法：我的是浏览器缓存问题，清除以下浏览器缓存就行了； 其他原因可以参考：hexo,部署博客到github和coding上，代码put上去了，但是访问博客内容却没更新？ 附上Hexo常用命令Hexo常用命令]]></content>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo问题记录]]></title>
    <url>%2F2019%2F07%2F16%2Fhexo%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[记录Hexo搭建过程遇到的一些问题问题一：4000端口被占用解决方法：1.可以用hexo server -p 5000 命令将端口修改为50002.可以在_config.yml内加上如下代码更改hexo-server运行时的端口号： server: port: 4001 compress: true header: true其中4001可以换成想要运行的端口号。参考链接: https://segmentfault.com/q/1010000008546859?_ea=1678427 问题二：出现错误如下：解决方法：打开根目录下的_config.yml文件，添加【图中xxx为自定义的名字】 注意缩进方式参考链接: https://www.cnblogs.com/fanbi/p/10174558.html Hexo搭建过程参考博文链接：https://blog.csdn.net/sinat_37781304/article/details/82729029https://blog.csdn.net/Hoshea_chx/article/details/78826689]]></content>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F07%2F15%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
