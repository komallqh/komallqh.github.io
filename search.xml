<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[正则表达式]]></title>
    <url>%2F2019%2F09%2F19%2F%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[正则表达式创建方式 字面量 1var regExp = /[a-z]\s/i 构造函数 1var regExp = new RegExp(&apos;[a-z]\\s&apos;,&apos;i&apos;) 特殊字符12345678910111213141516171819202122232425262728293031323334353637383940\ 转义字符^ $* 0次或多次+ 1次或多次？ 0次或1次 非贪婪 /e?le?/ 匹配 &quot;angel&quot; 中的 &apos;el&apos;、&quot;angle&quot; 中的 &apos;le&apos; 以及 &quot;oslo&apos; 中的 &apos;l&apos;。. 除换行符外任一字符；当标志符为s时，点号也可以匹配换行符(x) 它会匹配 &apos;x&apos; 并且记住匹配项。其中括号被称为捕获括号。$1,$2,...,x|y&#123;n&#125;&#123;n,&#125;&#123;n,m&#125;[xyz] 中括号中.（点号）和*可以不用转义，转义也没问题[^xyz][\b] 退格\b 使用&quot;moon&quot;举例： /\bm/匹配“moon”中的‘m’； /oo\b/并不匹配&quot;moon&quot;中的&apos;oo&apos;，因为&apos;oo&apos;被一个“字”字符&apos;n&apos;紧跟着。 /oon\b/匹配&quot;moon&quot;中的&apos;oon&apos;，因为&apos;oon&apos;是这个字符串的结束部分。这样他没有被一个“字”字符紧跟着。 /\w\b\w/将不能匹配任何字符串，因为在一个单词中间的字符永远也不可能同时满足没有“字”字符跟随和有“字”字符 跟随两种情况。\d\D\n 换行\r 回车\s\S\t\v\w\W\1 在正则表达式中，它返回最后的第n个子捕获匹配的子字符串(捕获的数目以左括号计数)。 比如 /apple(,)\sorange\1/ 匹配&quot;apple, orange, cherry, peach.&quot;中的&apos;apple, orange,&apos; 。\0 = null（？：x）如果表达式是 /foo&#123;1,2&#125;/，&#123;1,2&#125; 将只应用于 &apos;foo&apos;的最后一个字符&apos;o&apos;。如果使用非捕获括号，则 &#123;1,2&#125; 会应用于整个 &apos;foo&apos; 单词。 x（？=y）（？&lt;= y）xx（？！y）（？&lt;！y）x 与正则对象相关的属性123456789var myRe = /d(b+)d/g;var myArray = myRe.exec(&quot;cdbbdbsbz&quot;); console.log(myRe);console.log(myRe.source);console.log(myRe.lastIndex);console.log(myArray);//执行后//对象myRe拥有的属性：source lastIndex//对象myArray 拥有的属性：匹配的字符串，子表达式，index input 你可以使用一个正则表达式创建一个没有分配给变量的对象初始化容器。如果你这样做，那么，每一次使用时都好比在使用一个新的正则表达式。因为这个原因，如果你使用这个未分配给一个变量的正则表达式，你将在随后不能访问这个正则表达式的属性。 1234567var myRe = /d(b+)d/g;var myArray = myRe.exec(&quot;cdbbdbsbz&quot;);console.log(&quot;The value of lastIndex is &quot; + myRe.lastIndex); //The value of lastIndex is 5var myArray = /d(b+)d/g.exec(&quot;cdbbdbsbz&quot;);console.log(&quot;The value of lastIndex is &quot; + /d(b+)d/g.lastIndex); //The value of lastIndex is 0 与正则对象相关的方法 正则对象 exec方法：返回一个数组/null 1234567//有g【匹配文本，子表达式，index，input】，RegExpObject.lastIndex会指向下一个匹配的字符的索引；可以反复调用exec来遍历字符串中匹配的文本，当exec找不到时就会返回null，lastIndex = 0；注：若遍历一次后想重新开始遍历，需要lastIndex = 0//没有g【匹配文本，子表达式，index，input】，RegExp的lastIndex = 0//与String.match()的区别就是，无论是否有g都会返回完整细节 test方法：一个在字符串中测试是否匹配的RegExp方法，它返回 true 或 false。 1234var str = &quot;Visit W3School&quot;;var patt1 = new RegExp(&quot;W3School&quot;);var result = patt1.test(str); //true String对象(4种相关方法 ) match: 一个在字符串中执行查找匹配的String方法，它返回一个数组，在未匹配到时会返回 null。 123456789101112131415161718192021//没有子表达式情况//有gvar re = /\w+\s/g;var str = &quot;fee fi fo fum&quot;;var myArray = str.match(re);console.log(myArray); // [&quot;fee &quot;, &quot;fi &quot;, &quot;fo &quot;]//没有gvar re = /\w+\s/;var str = &quot;fee fi fo fum&quot;;var myArray = str.match(re);console.log(myArray); // [&quot;fee &quot;, index: 0, input: &quot;fee fi fo fum&quot;, groups: undefined]//有子表达式情况//有g ：返回所有匹配的字符串；而且没有子表达式，没有input和index属性str.match(/l([\w]+)/g) // str = &quot;Hello world!&quot;结果如下：[&quot;llo&quot;, &quot;ld&quot;]//没有g：【匹配文本，子表达式，index，input】str.match(/w(\w)+/) // str = &quot;Hello world!&quot;结果如下：[&quot;world&quot;, &quot;d&quot;, index: 6, input: &quot;Hello world!&quot;, groups: undefined] search一个在字符串中测试匹配的String方法，它返回匹配到的位置索引，或者在失败时返回-1。search() 方法不执行全局匹配，它将忽略标志 g。它同时忽略 regexp 的 lastIndex 属性，并且总是从字符串的开始进行检索，这意味着它总是返回 stringObject 的第一个匹配的位置。 1234567var str=&quot;Visit W3School!&quot;document.write(str.search(/W3School/)) //6var str=&quot;Visit W3School!&quot;document.write(str.search(/w3school/)) //-1 replace： 一个在字符串中执行查找匹配的String方法，并且使用替换字符串替换掉匹配到的子字符串$1、$2、…、$99 匹配 与 regexp 中的第 1 到第 99 个子表达式相匹配的文本。$&amp; 匹配 与 regexp 相匹配的子串。$` 匹配 位于匹配子串左侧的文本。$’ 匹配 位于匹配子串右侧的文本。$$ 匹配 直接量符号。 123456789101112name = &quot;Doe, John&quot;;name.replace(/(\w+)\s*, \s*(\w+)/, &quot;$2 $1&quot;);name = &apos;aaa bbb ccc&apos;;uw=name.replace(/\b\w+\b/g, function(word)&#123;return word.substring(0,1).toUpperCase()+word.substring(1);&#125;//???name = &apos;&quot;a&quot;, &quot;b&quot;&apos;;name.replace(/&quot;([^&quot;]*)&quot;/g, &quot;&apos;$1&apos;&quot;); ); split ：一个使用正则表达式或者一个固定字符串分隔一个字符串，并将分隔后的子字符串存储到数组中的 String 方法 1&quot;hello&quot;.split(&quot;&quot;, 3) //可返回 [&quot;h&quot;, &quot;e&quot;, &quot;l&quot;] 通过标志进行高级搜索g： 全局搜索 i: 不区分大小写 m: 多行搜索 s： 允许 . 匹配字符串 u： 使用unicode模式匹配 y： 执行“粘性”搜索,匹配从目标字符串的当前位置开始，可以使用y标志。()[]{} 记忆括号 []表示字符集[abc]匹配a或b或c {} {n,m}参考链接：MDN：https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions JavaScript exec() 方法https://www.w3school.com.cn/js/jsref_exec_regexp.aspJavaScript match() 方法https://www.w3school.com.cn/js/jsref_match.aspJavaScript test() 方法https://www.w3school.com.cn/js/jsref_test_regexp.aspJavaScript search() 方法https://www.w3school.com.cn/jsref/jsref_search.aspJavaScript split() 方法https://www.w3school.com.cn/js/jsref_split.aspJavaScript replace() 方法https://www.w3school.com.cn/jsref/jsref_replace.asp 正则表达式(括号)、[中括号]、{大括号}的区别小结https://blog.csdn.net/u010552788/article/details/51019367/]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[三种方式创建函数及构造函数与普通函数之间的区别]]></title>
    <url>%2F2019%2F09%2F15%2F%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F%E5%88%9B%E5%BB%BA%E5%87%BD%E6%95%B0%E5%8F%8A%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%8E%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[创建函数的三种方式：函数声明，函数表达式，函数对象 函数声明 1234function sum1(num1,num2)&#123; return num1+num2;&#125;sum1(10,20); 函数表达式 1234var sum2 = function(num1,num2)&#123; return num1+num2;&#125;sum(10,20); 函数对象形式 123456var sum3 = new Function(&quot;num1&quot;,&quot;num2&quot;,&quot;return num1+num2&quot;); //var 函数名 = new Function(“参数...”,”函数体”); var sum = new Function(&quot;num1,num2&quot;,&quot;return num1+num2&quot;); var result1 = sum(120,130); alert(result1) 构造函数和普通函数的区别 定义方式：构造函数首字母通常大写 调用方式：构造函数调用方法为：new Person() 普通函数调用方法为：person（） 作用：构造函数用来新建实例对象 构造函数的函数名与类名相同：Person( ) 这个构造函数，Person 既是函数名，也是这个对象的类名 构造函数内部用this 来构造属性和方法 12345678910 function Person(name,job,age)&#123; this.name=name; this.job=job; this.age=age; this.sayHi=function() &#123; alert(&quot;Hi&quot;) &#125; &#125; 构造函数的执行流程 在堆内存中创建一个新的对象 将this指向这个新建的对象 执行函数中的代码 将新建对象作为返回值 构造函数默认将新建对象返回，普通函数如果没定义返回值，则返回undefined 用instanceof 可以检查一个对象是否是一个类的实例，是则返回true；所有对象都是Object对象的后代，所以任何对象和Object做instanceof都会返回true 1234567function Person(name, age, gender)&#123; this.name = name; this.age = age;&#125; var per = new Person(&quot;komal&quot;,20);console.log(per); //Personconsole.log(per instanceof Person) //true 参考博文：https://blog.csdn.net/JinPingQ/article/details/84335179https://blog.csdn.net/weixin_41796631/article/details/82939585]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js数据类型转换及数据类型判断]]></title>
    <url>%2F2019%2F09%2F11%2Fjs%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E5%8F%8A%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%88%A4%E6%96%AD%2F</url>
    <content type="text"><![CDATA[数据类型js的数据类型有七种，其中有六种基本类型：null，undefined，boolean，string，number，symbol；以及一种引用类型：object 数据类型的转换显式转换一. 将非数值转换为数值类型的函数 ：Number(); parseInt(), parseFloat()Number() 函数转换规则： boolean：true转换为1，false转换为0 number：原样输出 undefined：输出NaN null：输出0 字符串：字符串中只包含数字（可带正负号，可为整数或小数）：转为十进制数，且忽略前导0； 字符串为十六进制，转为十进制； 空字符串：0； 其他：NaN 对象：如果是对象，则调用对象的valueOf()方法，然后依照前面的规则转换返回的值。如果转换的结果是NaN，则调用对象的toString()方法，然后再次按照前面的规则转换返回的字符串值1234560 == []; // true, 0 == [].toString(); ---&gt; 0 == 0;&apos;0&apos; == []; // false, &apos;0&apos; == [].toString(); ---&gt; &apos;0&apos; == &apos;&apos;;2 == [&apos;2&apos;]; // true, 2 == [&apos;2&apos;].valueOf(); ---&gt; 2 == &apos;2&apos; ---&gt; 2 == 2;&apos;2&apos; == [2]; // true, &apos;2&apos; == [2].toString(); ---&gt; &apos;2&apos; ==&apos;2&apos;; [] == ![]; //true, [].valueOf() == !Boolean([]) -&gt; 0 == false ---&gt; 0 == 0; parseInt(string [,radix]) parseInt不遵循四舍五入，radix的取值可为2-32 对于非字符串类型，先转换为字符串 从左向右遍历字符串，直到碰到非数字字符进行“截断”；如果第一个字符就是非数字字符，转换为NaN 123456789var num = [&quot;123&quot; , &quot;124.4&quot; , &quot;234asd&quot; , &quot;asf456&quot;] ; for (i = 0; i &lt; num.length; i++) &#123; console.log(parseInt(num[i])); &#125; //123 ， 124 ， 234 ， NaN parseInt(&apos;&apos;) //NaNparseInt(null) //NaNparseInt(undefined) //NaN 二. 将其它类型的数据转换为字符串类型的函数2.1 String(mix)：将mix转换成字符串类型。该函数可以将任何数据类型的值转换为字符串。2.2 toString(): num.toString([radix]) ：可以将数值（或其他除null，undefined外的数据类型）转换为字符类型，radix可选； 例：把一个二进制的数10001000转换成十六进制的数。 12var num1 = parseInt(&apos;10001000&apos;,2); //136var num2 = num1.toString(16); //&apos;88&apos; 三. 将值转换成布尔值类型：Boolean（）只有这七个值会返回false：undefined, null, -0, +0, NaN, ‘’(空字符), false; 其他情况都会返回true 123456789Boolean(1) ;//返回trueBoolean(&quot;0&quot;);//返回trueBoolean(&quot;abc&quot;);//返回trueBoolean([]); // trueBoolean(&#123;&#125;); // trueBoolean(new Boolean(false))// trueBoolean(false);//返回falseBoolean(&apos;&apos;);//返回falseBoolean(0);//返回false 隐式转换这里说的隐性类型转换，是==引起的转换。 如果存在NaN，一律返回false再看有没有布尔，有布尔就将布尔转换为数字接着看有没有字符串, 有三种情况，对方是对象，对象使用toString进行转换；对方是数字，字符串转数字；对方是字符串，直接比较；其他返回false如果是数字，对方是对象，对象取valueOf进行比较, 其他一律返回falsenull, undefined不会进行类型转换, 但它们俩相等这个顺序一定要死记，这是面试时经常问到的。 1234567891011121314151617181920212223240 == undefined //false1 == true //true2 == &#123;valueOf: function()&#123;return 2&#125;&#125; //trueNaN == NaN //false 8 == undefined //false1 == undefined //false null == &#123;toString: function()&#123;return 2&#125;&#125; //false 0 == null //false null == 1 //false 1 == &#123; toString:function()&#123; return 1 &#125; , valueOf:function()&#123; return [] &#125;&#125; //true//undefined不发生类型转换 console.log(undefined == undefined); //true console.log(undefined == 0); //false console.log(undefined &gt; 0); //false console.log(undefined &lt; 0); //false //null不发生类型转换 console.log(null == null); //true console.log(null &gt;= 0); //true console.log(null == 0); //false console.log(null &gt; 0); //false console.log(null &lt; 0); //false console.log(undefined == null); //true 隐式转换为字符 +””(空字符串)1234567891011121314151617 var a; var b = a + &quot;&quot;; console.log(typeof b + &quot; &quot; + b); a = null; b = a + &quot;&quot;; console.log(typeof b + &quot; &quot; + b); a = 123; b = a + &quot;&quot;; console.log(typeof b + &quot; &quot; + b); a = true; b = a + &quot;&quot;; console.log(typeof b + &quot; &quot; + b);null+&quot;3&quot; //&quot;null3&quot; 隐式转换为数值123+‘3’ // 3 注意与null+&apos;3&apos;的区别！‘10’-20 // -1010-‘one’ // NaN 隐式转换为boolean!!num 相当于调用 Boolean(num) 关于null == 0要比较相等性之前，不能将null和undefined转换成其他任何值。就是undefined和null与其他数在进行相等判断时不进行类型转换。null == undefined,这个是true null&gt;0 //null转化为number，为0，所以0&gt;0结果为false。null&gt;=0 //null转化为number，为0&gt;=0，所以结果为true。null==0// null在做相等判断时，不进行转型，所以null和0为不同类型数据，结果为false 关于NaNNaN属于number类型,NaN与任何值都不相等方法 parseInt() 和 parseFloat() 在不能解析指定的字符串时就返回这个值。 12typeof(NaN) //numberNaN === NaN //false 注意Number.isNaN()和isNaN的区别: 12345678910console.log(Number.isNaN(NaN)); // trueconsole.log(Number.isNaN(Math.sqrt(-2))); // trueconsole.log(Number.isNaN(&apos;hello&apos;)); // falseconsole.log(Number.isNaN([&apos;x&apos;])); // falseconsole.log(Number.isNaN(&#123;&#125;)); // falseconsole.log(isNaN(&apos;hello&apos;)); // trueconsole.log(isNaN([&apos;x&apos;])); // trueconsole.log(isNaN(&#123;&#125;)); // true 数据类型判断的四种方法 typeof typeof的返回值有6种：“number”、”string”、”boolean”、”object”、”function”、”undefined” typeof对于基本数据类型判断是没有问题的，但是遇到引用数据类型（如：Array）是不起作用的，返回object 1typeof [] ; //object instanceofinstanceof 是用来判断 A 是否为 B 的实例，表达式为：A instanceof B，如果 A 是 B 的实例，则返回 true,否则返回 false。 在这里需要特别注意的是：instanceof 检测的是原型，我们用一段伪代码来模拟其内部执行过程： 123456789instanceof (A,B) = &#123; var L = A.__proto__; var R = B.prototype; if(L === R) &#123; // A的内部属性 __proto__ 指向 B 的原型对象 return true; &#125; return false;&#125; 从上述过程可以看出，当 A 的 proto 指向 B 的 prototype 时，就认为 A 就是 B 的实例，我们再来看几个例子 12345678910[] instanceof Array; // true&#123;&#125; instanceof Object;// truenew Date() instanceof Date;// true function Person()&#123;&#125;;new Person() instanceof Person; [] instanceof Object; // truenew Date() instanceof Object;// truenew Person instanceof Object;// true instanceof 只能用来判断两个对象是否属于实例关系， 而不能判断一个对象实例具体属于哪种类型。 instanceof 操作符的问题在于，它假定只有一个全局执行环境。如果网页中包含多个框架，那实际上就存在两个以上不同的全局执行环境，从而存在两个以上不同版本的构造函数。如果你从一个框架向另一个框架传入一个数组，那么传入的数组与在第二个框架中原生创建的数组分别具有各自不同的构造函数。 12345var iframe = document.createElement(&apos;iframe&apos;);document.body.appendChild(iframe);xArray = window.frames[0].Array;var arr = new xArray(1,2,3); // [1,2,3]arr instanceof Array; // false 针对数组的这个问题，ES5 提供了 Array.isArray() 方法 。该方法用以确认某个对象本身是否为 Array 类型，而不区分该对象在哪个环境中创建。 注意： 1234567console.log(&quot;1&quot; instanceof String); //falseconsole.log(1 instanceof Number); //falseconsole.log(true instanceof Boolean); //falsenew Number(1) instanceof Number; //truenew String(&apos;1&apos;) instanceof Number; //truenew Boolean(false) instanceof Number; //true constructornull 和 undefined 是无效的对象，因此是不会有 constructor 存在的，这两种类型的数据需要通过其他方式来判断。 函数的 constructor 是不稳定的，这个主要体现在自定义对象上，当开发者重写 prototype 后，原有的 constructor 引用会丢失，constructor 会默认为 Object 1234567function Fn()&#123;&#125;;Fn.prototype=new Array();var f=new Fn();console.log(f.constructor===Fn); //falseconsole.log(f.constructor===Array); //true Object.prototype.toString.call(true)12345678910111213Object.prototype.toString.call(&apos;&apos;) ; // [object String]Object.prototype.toString.call(1) ; // [object Number]Object.prototype.toString.call(true) ; // [object Boolean]Object.prototype.toString.call(Symbol()); //[object Symbol]Object.prototype.toString.call(undefined) ; // [object Undefined]Object.prototype.toString.call(null) ; // [object Null]Object.prototype.toString.call(new Function()) ; // [object Function]Object.prototype.toString.call(new Date()) ; // [object Date]Object.prototype.toString.call([]) ; // [object Array]Object.prototype.toString.call(new RegExp()) ; // [object RegExp]Object.prototype.toString.call(new Error()) ; // [object Error]Object.prototype.toString.call(document) ; // [object HTMLDocument]Object.prototype.toString.call(window) ; //[object global] window 是全局对象 global 的引用 参考链接 数据类型转换 https://www.jb51.net/article/136520.htm https://www.jb51.net/article/136521.htm https://blog.csdn.net/qq2071114140/article/details/92478526 https://blog.csdn.net/luckydie/article/details/77948097 https://blog.csdn.net/Doulvme/article/details/83104683 判断数据类型 https://www.cnblogs.com/onepixel/p/5126046.html https://www.cnblogs.com/zt123123/p/7623409.html]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript实现排序算法]]></title>
    <url>%2F2019%2F09%2F10%2FJavaScript%E5%AE%9E%E7%8E%B0%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[实现了冒泡，选择，插入，快排，希尔，归并 冒泡排序123456789101112131415161718192021//外层遍历：len-1&gt;=i&gt;0; i--//内层遍历：0&lt;=j&lt;i; j++//定义一个flag做代码优化 function bubbleSort(arr)&#123; var len = arr.length; var tmp; for(var i=len-1; i&gt;0; i++)&#123; var flag = true; for(var j=0; j&lt;i; j++)&#123; if(arr[j]&gt;arr[j+1])&#123; tmp = arr[j]; arr[j] = arr[j+1]; arr[j+1] = tmp; flag = false; &#125; &#125; if(flag)&#123; return arr; &#125; &#125; &#125; 选择排序12345678910111213141516171819202122232425//外层排序：1&lt;=i&lt;len; i++;//内层排序：i+1&lt;=j&lt;len; j++//左侧默认有序，从右边选出一个最小值来与最左边的最大值进行交换function selectSort(arr)&#123; var len = arr.length; var minIndex, temp; for(var i=0; i&lt;len-1; i++)&#123; minIndex = i; for(var j=i+1; j&lt;len; j++)&#123; //找出右边的最小值 if(arr[j]&lt;arr[minIndex])&#123; minIndex = j; &#125; &#125; if(minIndex !== i)&#123; temp = arr[i]; arr[i] = arr[minIndex]; arr[minIndex] = temp; &#125; &#125; return arr;&#125; 插入排序1234567891011121314151617//外层循环：1&lt;=i&lt;len; i++;//内层循环：记录arr[i],当左边默认排好序的数组中的数比arr[i]大时，将它们左移function insertSort(arr)&#123; var len = arr.length; if(len&lt;=1) return arr; for(var i=1; i&lt;len; i++)&#123; var j = i; var temp = arr[i]; while(j&gt;0 &amp;&amp; arr[j-1]&gt;temp)&#123; arr[j] = arr[j-1]; --j; &#125; arr[j] = temp; &#125; return arr;&#125; 快速排序123456789101112131415161718//注意：需要加上if(arr.length &lt;=1) return arr;//否则会导致栈溢出function quickSort(arr)&#123; if(arr.length &lt;= 1) return arr; var num = Math.floor(arr.length/2); var numValue = arr.splice(num,1); var left = []; var right = []; //此处判断条件为i&lt;arr.length;不能是i&lt;len;因为前面已经进行过splice操作，此时的len与arr.length并不相等 for(var i=0; i&lt;arr.length; i++)&#123; if(arr[i]&lt;numValue)&#123; left.push(arr[i]) &#125;else&#123; right.push(arr[i]) &#125; &#125; return quickSort(left).concat(numValue,quickSort(right))&#125; 希尔排序123456789101112131415161718192021222324252627282930function shellSort(arr)&#123; // 1.获取数组的长度 var length = arr.length // 2.根据长度计算增量 var gap = Math.floor(length / 2) // 3.增量不断变量小, 大于0就继续排序 while (gap &gt; 0) &#123; // 4.实现插入排序 for (var i = gap; i &lt; length; i++) &#123; // 4.1.保存临时变量 var j = i var temp = arr[i] // 4.2.插入排序的内层循环 while (j-gap&gt;=0 &amp;&amp; arr[j - gap] &gt; temp) &#123; arr[j] = arr[j - gap] j -= gap &#125; // 4.3.将选出的j位置设置为temp arr[j] = temp &#125; // 5.重新计算新的间隔 gap = Math.floor(gap / 2) &#125; return arr;&#125; 归并排序123456789101112131415161718192021222324252627282930313233//归并排序//分治法//先将一个数组分为左右两个数组 function mergeSort(arr)&#123; var len = arr.length; if(len&lt;2) return arr; var middle = Math.floor(len/2); var left = arr.slice(0,middle); var right = arr.slice(middle); return merge(left,right);&#125;//将左右两个数组排序后以result返回function merge(left,right)&#123; var result = []; while(left.length&gt;0 &amp;&amp; right.length&gt;0)&#123; if(left[0]&lt;=right[0])&#123; result.push(left.shift()); &#125;else&#123; result.push(right.shift()); &#125; &#125; while(left.length)&#123; result.push(left.shift()); &#125; while(right.length)&#123; result.push(right.shift()); &#125; return result;&#125;]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[事件监听和事件绑定]]></title>
    <url>%2F2019%2F09%2F10%2F%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC%E5%92%8C%E4%BA%8B%E4%BB%B6%E7%BB%91%E5%AE%9A%2F</url>
    <content type="text"><![CDATA[事件监听addEventListener 和 attachEvent区别addEventListener，removeEventListener是DOM2级事件定义的方法； addEventListener有三个参数：事件类型，执行函数，是否捕获；addEventListener可以实现同一个元素绑定多个click事件，当条件触发时，会依次执行相应的函数 例如 12345 //element.addEventListener(type,listener,useCapture);btn1Obj.addEventListener(&quot;click&quot;,method1,false);btn1Obj.addEventListener(&quot;click&quot;,method2,false);btn1Obj.addEventListener(&quot;click&quot;,method3,false);//执行顺序为method1-&gt;method2-&gt;method3 attachEvent 和detachEvent是IE7，8可用的方法；attachEvent接受两个参数：类型（要加上on），和执行函数；这两个方法支持冒泡阶段执行；当同一个元素也可以绑定多个click事件时，执行顺序与addEventListener的执行顺序相反； 12345btn1Obj.attachEvent(&quot;onclick&quot;,method1);btn1Obj.attachEvent(&quot;onclick&quot;,method2);btn1Obj.attachEvent(&quot;onclick&quot;,method3);//使用格式是前面是事件类型,注意的是需要加on,比如onclick,onsubmit,onchange,执行顺序是//method3-&gt;method2-&gt;method1 兼容性写法12345678910function myAddEvent(obj, ev, fn,useCapture) //obj为要绑定事件的元素，ev为要绑定的事件，fn为绑定事件的函数,userCapture为是否在捕获阶段执行 &#123; var useCapture = useCapture || false; if(obj.attachEvent) &#123; obj.attachEvent(&quot;on&quot; + ev, fn); &#125; else &#123; obj.addEventListener(ev, fn, useCapture); &#125; &#125; 事件绑定三种事件绑定方式 onclik调用 123&lt;button id=&quot;btn&quot;&gt;click&lt;/button&gt; var btn = document.getElementById(&apos;btn&apos;); btn.onclick = function()&#123;alert(1)&#125;; addEventListener调用 123&lt;button id=&quot;btn&quot;&gt;click&lt;/button&gt;var btn = document.getElementById(&apos;btn&apos;);btn.addEventListener(&apos;click&apos;,function()&#123;alert(2)&#125;,false); DOM结构中调用 1234 &lt;button id=&quot;btn&quot; onclick =&quot;demo()&quot;&gt;click&lt;/button&gt;function demo()&#123; alert(3) &#125; click() 和 onclick() 12document.getElementById(&quot;target&quot;).onclick(); document.getElementById(&quot;target&quot;).click(); click()是真正地用程序取点击按钮，触发了onclick()事件；onclick()只是简单地调用了btn的onclick所指向的方法，只是调用方法而已，并未触发事件 onclick绑定多个事件会覆盖用 “addeventlistener” 可以绑定多次同一个事件，且都会执行，而在DOM结构如果绑定两个 “onclick” 事件，只会执行第一个；在脚本通过匿名函数的方式绑定的只会执行最后一个事件。 1234567891011121314151617181920212223242526272829303132331. &lt;div id=&quot;btn&quot; onclick=&quot;clickone()&quot; onclick=&quot;clicktwo()&quot;&gt;&lt;/div&gt; &lt;script&gt; function clickone()&#123; alert(&quot;hello&quot;); &#125; //执行这个 function clicktwo()&#123; alert(&quot;world!&quot;); &#125; &lt;/script&gt; 2. &lt;div id=&quot;btn&quot;&gt;&lt;/div&gt; &lt;script&gt; document.getElementById(&quot;btn&quot;).onclick = function（）&#123; alert(&quot;hello&quot;); &#125; document.getElementById(&quot;btn&quot;).onclick = function（）&#123; alert(&quot;world&quot;); &#125; //执行这个 &lt;/script&gt; 3. &lt;div id=&quot;btn&quot;&gt;&lt;/div&gt; &lt;script&gt; document.getElementById(&quot;btn&quot;).addeventlistener(&quot;click&quot;,clickone,false); function clickone()&#123; alert(&quot;hello&quot;); &#125; //先执行 document.getElementById(&quot;btn&quot;).addeventlistener(&quot;click&quot;,clicktwo,false); function clicktwo()&#123; alert(&quot;world&quot;); &#125; //后执行 &lt;/script&gt; 参考博文： https://www.jianshu.com/p/4af0476a08c9 https://blog.csdn.net/longzhoufeng/article/details/80689150 https://blog.csdn.net/andrewniu/article/details/81102114 https://blog.csdn.net/ion_l/article/details/82662126]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浏览器内核]]></title>
    <url>%2F2019%2F09%2F07%2F%E6%B5%8F%E8%A7%88%E5%99%A8%E5%86%85%E6%A0%B8%2F</url>
    <content type="text"><![CDATA[浏览器内核分为两部分：一是渲染引擎，其主要负责结构与样式，即网页的内容（HTML，XML，图像等），以及计算网页显示方式，然后输出到打印机；而JS引擎主要是负责解析JavaScript，实现页面交互效果；一个负责搭建静态结构，一个用来展现动态效果；后来js引擎越来越独立，浏览器内核便更加倾向于指渲染引擎。 目前常见浏览器及其内核IE浏览器：ie11之前用Trident内核，后来的Edge采用了新内核（EdgeHTML）火狐浏览器：使用Gecko内核（开源）Safari：使用Webkit内核；而且Webkit最先是由苹果开发的Chrome浏览器：Chrome内核➡Webkit内核➡Blink内核；另外谷歌后来还研发了自己的JavaScript引擎：V8，极大地提高了JavaScript运行速度Opera：最初是自己研发的Presto，后来同谷歌一样用了Webkit，现在也是Blink内核国内浏览器大多数是双核模式：标准模式下为chrome内核，兼容模式下为IE内核 浏览器渲染引擎的工作原理先了解一下浏览器的主要组成部分：用户界面，浏览器引擎，渲染引擎，网络请求模块，JS引擎，用户界面后端，数据层。各部分的作用为：用户界面：包括如地址栏，书签栏等内容构成了浏览器的用户界面，用来实现与用户之间的交互浏览器引擎：用于在渲染引擎和用户界面之间传递命令渲染引擎：当获取到请求的页面资源后，浏览器先解析HTML文档构建“结构树”，然后解析CSS文件，为“结构树”添加样式形成”渲染树“，接下来就是布局过程，为“渲染树”分配屏幕的位置坐标，最后进入绘制阶段，利用UI后端绘制出“渲染树”的每一个节点；另外，为了更好用户体验，浏览器引擎不会等到所有html解析完成后再去构建和布局render树。它是完成解析完一部分内容就显示一部分内容，于此同时还可能通过网络下载相关内容网络请求模块：实现网络请求以及数据接收JS引擎：负责解析JS代码UI后端：负责绘制基本的部件，在底层与操作系统进行交互数据存储：负责存储数据 浏览器页面渲染过程（及尽量避免重绘回流的操作）1 用户输入网址（假设是HTML页面，第一次访问，无缓存） 浏览器想服务器发出HTTP请求，服务器返回HTML文件（善用缓存，减少HTTP请求，减轻服务器压力） 浏览器载入HTML代码，获取CSS文件（CSS文件合并，减少HTTP请求） 载入&lt;body&gt;，开始渲染页面（CSS文件放在最上面，避免重复渲染 ） 浏览器发现一个&lt;img&gt;，向服务器发出请求，此时浏览器不会等到图片下载完，而是继续渲染后面的代码（图片文件合并，减少HTTP请求） 服务器返回图片文件，由于图片面积，影响界面中其他元素的排版，此时，浏览器需要重新渲染这部分代码（最好图片都设置尺寸，避免重新渲染） 浏览器发现一个包含js代码的&lt;script&gt;标签，会立即运行该js代码（script最好放在页面最下面） js执行命令：隐藏掉代码中某个div元素，此时浏览器不得不重新渲染这部分代码（页面初始化样式不要使用js控制） 如果某时刻，用户通过点击某个按钮修个这个页面样式（如换肤），请求新的CSS文件，此时发生回流，重新渲染页面 关于reflow和repaintreflow：某个样式发生改变影响页面的布局，发生回流；reflow几乎无法避免，如树目录的折叠展开效果都会引起reflowrepaint：改变某个元素的背景色，文字或边框颜色等不影响布局的属性，成为repaint；reflow的成本比repaint高； 引起reflow的情况（标准流内的元素发生形态上的改变） 改变窗囗大小 改变文字大小 添加/删除样式表 内容的改变，如用户在输入框中敲字 激活伪类，如:hover (IE里是一个兄弟结点的伪类被激活) 操作class属性 脚本操作DOM 计算offsetWidth和offsetHeight 设置style属性reflow是不可避免的，只能将reflow对性能的影响减到最小。 尽可能限制reflow的影响范围。需要改变元素的样式，不要通过父级元素影响子元素。最好直接加在子元素上。 通过设置style属性改变结点样式的话，每设置一次都会导致一次reflow。所以最好通过设置class的方式。 实现元素的动画，它的position属性应当设为fixed或absolute，这样不会影响其它元素的布局。 权衡速度的平滑。比如实现一个动画，以1个像素为单位移动这样最平滑，但reflow就会过于频繁，CPU很快就会被完全占用。如果以3个像素为单位移动就会好很多。 不要用tables布局的另一个原因就是tables中某个元素一旦触发reflow就会导致table里所有的其它元素reflow。在适合用table的场合，可以设置table-layout为auto或fixed，这样可以让table一行一行的渲染，这种做法也是为了限制reflow的影响范围。 很多情况下都会触发reflow，如果css里有expression，每次都会重新计算一遍。 减少不必要的 DOM 层级（DOM depth）。改变 DOM 树中的一级会导致所有层级的改变，上至根部，下至被改变节点的子节点。这导致大量时间耗费在执行 reflow 上面。 避免不必要的复杂的 CSS 选择器，尤其是后代选择器（descendant selectors），因为为了匹配选择器将耗费更多的 CPU 从输入url到加载完成过程]]></content>
      <tags>
        <tag>浏览器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo主题修改]]></title>
    <url>%2F2019%2F09%2F06%2Fhexo%E4%B8%BB%E9%A2%98%E4%BF%AE%E6%94%B9%2F</url>
    <content type="text"><![CDATA[修改Hexo主题及问题记录 昨晚试着将段时间搭建的hexo改一下主题，觉得NexT.Mist看起来挺简洁，挺喜欢这种风格的； 以下主要是一个索引，记录我搭建以及修改过程所参考的文章搭建博客 当时搭建博客主要参考的博文有： Hexo官方文档 hexo史上最全搭建教程 NexT.Mist主题参考的博文： next官方文档 Hexo的Next主题详细配置 修改主题过程遇到的一些小失误 hexo new page tag 创建标签页时报错： FATAL can not read a block mapping entry; a multiline key may not be an implicit key at line 70, column 1: … 错误 解决办法：_config.yml中配置项的冒号后面要用空格隔开，再跟内容 将Hexo设置首页不显示全文 方法：在主题配置文件_config.yml中找到auto_excerpt字段，将enable修改为true，可以实现首页显示文章预览；不过这 并不是Hexo推荐的方法；Hexo推荐在文章中使用&lt;!-- more --&gt;在more之前的内容会显现在首页的文章预览中，而more之后的内容可以在文章详情中显示 Hexo瞎折腾系列(4) - 站点首页不显示文章全文 中文乱码问题：将_config.yml的格式保存为UTF-8 hexo,部署博客到github和coding上，代码put上去了，但是访问博客内容却没更新？ 解决方法：我的是浏览器缓存问题，清除以下浏览器缓存就行了； 其他原因可以参考：hexo,部署博客到github和coding上，代码put上去了，但是访问博客内容却没更新？ 附上Hexo常用命令Hexo常用命令]]></content>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo问题记录]]></title>
    <url>%2F2019%2F07%2F16%2Fhexo%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[记录Hexo搭建过程遇到的一些问题问题一：4000端口被占用解决方法：1.可以用hexo server -p 5000 命令将端口修改为50002.可以在_config.yml内加上如下代码更改hexo-server运行时的端口号： server: port: 4001 compress: true header: true其中4001可以换成想要运行的端口号。参考链接: https://segmentfault.com/q/1010000008546859?_ea=1678427 问题二：出现错误如下：解决方法：打开根目录下的_config.yml文件，添加【图中xxx为自定义的名字】 注意缩进方式参考链接: https://www.cnblogs.com/fanbi/p/10174558.html Hexo搭建过程参考博文链接：https://blog.csdn.net/sinat_37781304/article/details/82729029https://blog.csdn.net/Hoshea_chx/article/details/78826689]]></content>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F07%2F15%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
