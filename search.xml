<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[三种方式创建函数及构造函数与普通函数之间的区别]]></title>
    <url>%2F2019%2F09%2F15%2F%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F%E5%88%9B%E5%BB%BA%E5%87%BD%E6%95%B0%E5%8F%8A%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%8E%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[创建函数的三种方式：函数声明，函数表达式，函数对象 函数声明 1234function sum1(num1,num2)&#123; return num1+num2;&#125;sum1(10,20); 函数表达式 1234var sum2 = function(num1,num2)&#123; return num1+num2;&#125;sum(10,20); 函数对象形式 123456var sum3 = new Function(&quot;num1&quot;,&quot;num2&quot;,&quot;return num1+num2&quot;); //var 函数名 = new Function(“参数...”,”函数体”); var sum = new Function(&quot;num1,num2&quot;,&quot;return num1+num2&quot;); var result1 = sum(120,130); alert(result1) 构造函数和普通函数的区别 定义方式：构造函数首字母通常大写 调用方式：构造函数调用方法为：new Person() 普通函数调用方法为：person（） 作用：构造函数用来新建实例对象 构造函数的函数名与类名相同：Person( ) 这个构造函数，Person 既是函数名，也是这个对象的类名 构造函数内部用this 来构造属性和方法 12345678910 function Person(name,job,age)&#123; this.name=name; this.job=job; this.age=age; this.sayHi=function() &#123; alert(&quot;Hi&quot;) &#125; &#125; 构造函数的执行流程 在堆内存中创建一个新的对象 将this指向这个新建的对象 执行函数中的代码 将新建对象作为返回值 构造函数默认将新建对象返回，普通函数如果没定义返回值，则返回undefined 用instanceof 可以检查一个对象是否是一个类的实例，是则返回true；所有对象都是Object对象的后代，所以任何对象和Object做instanceof都会返回true 1234567function Person(name, age, gender)&#123; this.name = name; this.age = age;&#125; var per = new Person(&quot;komal&quot;,20);console.log(per); //Personconsole.log(per instanceof Person) //true 参考博文：https://blog.csdn.net/JinPingQ/article/details/84335179https://blog.csdn.net/weixin_41796631/article/details/82939585]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript实现排序算法]]></title>
    <url>%2F2019%2F09%2F10%2FJavaScript%E5%AE%9E%E7%8E%B0%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[实现了冒泡，选择，插入，快排，希尔，归并 冒泡排序123456789101112131415161718192021//外层遍历：len-1&gt;=i&gt;0; i--//内层遍历：0&lt;=j&lt;i; j++//定义一个flag做代码优化 function bubbleSort(arr)&#123; var len = arr.length; var tmp; for(var i=len-1; i&gt;0; i++)&#123; var flag = true; for(var j=0; j&lt;i; j++)&#123; if(arr[j]&gt;arr[j+1])&#123; tmp = arr[j]; arr[j] = arr[j+1]; arr[j+1] = tmp; flag = false; &#125; &#125; if(flag)&#123; return arr; &#125; &#125; &#125; 选择排序12345678910111213141516171819202122232425//外层排序：1&lt;=i&lt;len; i++;//内层排序：i+1&lt;=j&lt;len; j++//左侧默认有序，从右边选出一个最小值来与最左边的最大值进行交换function selectSort(arr)&#123; var len = arr.length; var minIndex, temp; for(var i=0; i&lt;len-1; i++)&#123; minIndex = i; for(var j=i+1; j&lt;len; j++)&#123; //找出右边的最小值 if(arr[j]&lt;arr[minIndex])&#123; minIndex = j; &#125; &#125; if(minIndex !== i)&#123; temp = arr[i]; arr[i] = arr[minIndex]; arr[minIndex] = temp; &#125; &#125; return arr;&#125; 插入排序1234567891011121314151617//外层循环：1&lt;=i&lt;len; i++;//内层循环：记录arr[i],当左边默认排好序的数组中的数比arr[i]大时，将它们左移function insertSort(arr)&#123; var len = arr.length; if(len&lt;=1) return arr; for(var i=1; i&lt;len; i++)&#123; var j = i; var temp = arr[i]; while(j&gt;0 &amp;&amp; arr[j-1]&gt;temp)&#123; arr[j] = arr[j-1]; --j; &#125; arr[j] = temp; &#125; return arr;&#125; 快速排序123456789101112131415161718//注意：需要加上if(arr.length &lt;=1) return arr;//否则会导致栈溢出function quickSort(arr)&#123; if(arr.length &lt;= 1) return arr; var num = Math.floor(arr.length/2); var numValue = arr.splice(num,1); var left = []; var right = []; //此处判断条件为i&lt;arr.length;不能是i&lt;len;因为前面已经进行过splice操作，此时的len与arr.length并不相等 for(var i=0; i&lt;arr.length; i++)&#123; if(arr[i]&lt;numValue)&#123; left.push(arr[i]) &#125;else&#123; right.push(arr[i]) &#125; &#125; return quickSort(left).concat(numValue,quickSort(right))&#125; 希尔排序123456789101112131415161718192021222324252627282930function shellSort(arr)&#123; // 1.获取数组的长度 var length = arr.length // 2.根据长度计算增量 var gap = Math.floor(length / 2) // 3.增量不断变量小, 大于0就继续排序 while (gap &gt; 0) &#123; // 4.实现插入排序 for (var i = gap; i &lt; length; i++) &#123; // 4.1.保存临时变量 var j = i var temp = arr[i] // 4.2.插入排序的内层循环 while (j-gap&gt;=0 &amp;&amp; arr[j - gap] &gt; temp) &#123; arr[j] = arr[j - gap] j -= gap &#125; // 4.3.将选出的j位置设置为temp arr[j] = temp &#125; // 5.重新计算新的间隔 gap = Math.floor(gap / 2) &#125; return arr;&#125; 归并排序123456789101112131415161718192021222324252627282930313233//归并排序//分治法//先将一个数组分为左右两个数组 function mergeSort(arr)&#123; var len = arr.length; if(len&lt;2) return arr; var middle = Math.floor(len/2); var left = arr.slice(0,middle); var right = arr.slice(middle); return merge(left,right);&#125;//将左右两个数组排序后以result返回function merge(left,right)&#123; var result = []; while(left.length&gt;0 &amp;&amp; right.length&gt;0)&#123; if(left[0]&lt;=right[0])&#123; result.push(left.shift()); &#125;else&#123; result.push(right.shift()); &#125; &#125; while(left.length)&#123; result.push(left.shift()); &#125; while(right.length)&#123; result.push(right.shift()); &#125; return result;&#125;]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[事件监听和事件绑定]]></title>
    <url>%2F2019%2F09%2F10%2F%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC%E5%92%8C%E4%BA%8B%E4%BB%B6%E7%BB%91%E5%AE%9A%2F</url>
    <content type="text"><![CDATA[事件监听addEventListener 和 attachEvent区别addEventListener，removeEventListener是DOM2级事件定义的方法； addEventListener有三个参数：事件类型，执行函数，是否捕获；addEventListener可以实现同一个元素绑定多个click事件，当条件触发时，会依次执行相应的函数 例如 12345 //element.addEventListener(type,listener,useCapture);btn1Obj.addEventListener(&quot;click&quot;,method1,false);btn1Obj.addEventListener(&quot;click&quot;,method2,false);btn1Obj.addEventListener(&quot;click&quot;,method3,false);//执行顺序为method1-&gt;method2-&gt;method3 attachEvent 和detachEvent是IE7，8可用的方法；attachEvent接受两个参数：类型（要加上on），和执行函数；这两个方法支持冒泡阶段执行；当同一个元素也可以绑定多个click事件时，执行顺序与addEventListener的执行顺序相反； 12345btn1Obj.attachEvent(&quot;onclick&quot;,method1);btn1Obj.attachEvent(&quot;onclick&quot;,method2);btn1Obj.attachEvent(&quot;onclick&quot;,method3);//使用格式是前面是事件类型,注意的是需要加on,比如onclick,onsubmit,onchange,执行顺序是//method3-&gt;method2-&gt;method1 兼容性写法12345678910function myAddEvent(obj, ev, fn,useCapture) //obj为要绑定事件的元素，ev为要绑定的事件，fn为绑定事件的函数,userCapture为是否在捕获阶段执行 &#123; var useCapture = useCapture || false; if(obj.attachEvent) &#123; obj.attachEvent(&quot;on&quot; + ev, fn); &#125; else &#123; obj.addEventListener(ev, fn, useCapture); &#125; &#125; 事件绑定三种事件绑定方式 onclik调用 123&lt;button id=&quot;btn&quot;&gt;click&lt;/button&gt; var btn = document.getElementById(&apos;btn&apos;); btn.onclick = function()&#123;alert(1)&#125;; addEventListener调用 123&lt;button id=&quot;btn&quot;&gt;click&lt;/button&gt;var btn = document.getElementById(&apos;btn&apos;);btn.addEventListener(&apos;click&apos;,function()&#123;alert(2)&#125;,false); DOM结构中调用 1234 &lt;button id=&quot;btn&quot; onclick =&quot;demo()&quot;&gt;click&lt;/button&gt;function demo()&#123; alert(3) &#125; click() 和 onclick() 12document.getElementById(&quot;target&quot;).onclick(); document.getElementById(&quot;target&quot;).click(); click()是真正地用程序取点击按钮，触发了onclick()事件；onclick()只是简单地调用了btn的onclick所指向的方法，只是调用方法而已，并未触发事件 onclick绑定多个事件会覆盖用 “addeventlistener” 可以绑定多次同一个事件，且都会执行，而在DOM结构如果绑定两个 “onclick” 事件，只会执行第一个；在脚本通过匿名函数的方式绑定的只会执行最后一个事件。 1234567891011121314151617181920212223242526272829303132331. &lt;div id=&quot;btn&quot; onclick=&quot;clickone()&quot; onclick=&quot;clicktwo()&quot;&gt;&lt;/div&gt; &lt;script&gt; function clickone()&#123; alert(&quot;hello&quot;); &#125; //执行这个 function clicktwo()&#123; alert(&quot;world!&quot;); &#125; &lt;/script&gt; 2. &lt;div id=&quot;btn&quot;&gt;&lt;/div&gt; &lt;script&gt; document.getElementById(&quot;btn&quot;).onclick = function（）&#123; alert(&quot;hello&quot;); &#125; document.getElementById(&quot;btn&quot;).onclick = function（）&#123; alert(&quot;world&quot;); &#125; //执行这个 &lt;/script&gt; 3. &lt;div id=&quot;btn&quot;&gt;&lt;/div&gt; &lt;script&gt; document.getElementById(&quot;btn&quot;).addeventlistener(&quot;click&quot;,clickone,false); function clickone()&#123; alert(&quot;hello&quot;); &#125; //先执行 document.getElementById(&quot;btn&quot;).addeventlistener(&quot;click&quot;,clicktwo,false); function clicktwo()&#123; alert(&quot;world&quot;); &#125; //后执行 &lt;/script&gt; 参考博文： https://www.jianshu.com/p/4af0476a08c9 https://blog.csdn.net/longzhoufeng/article/details/80689150 https://blog.csdn.net/andrewniu/article/details/81102114 https://blog.csdn.net/ion_l/article/details/82662126]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浏览器内核]]></title>
    <url>%2F2019%2F09%2F07%2F%E6%B5%8F%E8%A7%88%E5%99%A8%E5%86%85%E6%A0%B8%2F</url>
    <content type="text"><![CDATA[浏览器内核分为两部分：一是渲染引擎，其主要负责结构与样式，即网页的内容（HTML，XML，图像等），以及计算网页显示方式，然后输出到打印机；而JS引擎主要是负责解析JavaScript，实现页面交互效果；一个负责搭建静态结构，一个用来展现动态效果；后来js引擎越来越独立，浏览器内核便更加倾向于指渲染引擎。 目前常见浏览器及其内核IE浏览器：ie11之前用Trident内核，后来的Edge采用了新内核（EdgeHTML）火狐浏览器：使用Gecko内核（开源）Safari：使用Webkit内核；而且Webkit最先是由苹果开发的Chrome浏览器：Chrome内核➡Webkit内核➡Blink内核；另外谷歌后来还研发了自己的JavaScript引擎：V8，极大地提高了JavaScript运行速度Opera：最初是自己研发的Presto，后来同谷歌一样用了Webkit，现在也是Blink内核国内浏览器大多数是双核模式：标准模式下为chrome内核，兼容模式下为IE内核 浏览器渲染引擎的工作原理先了解一下浏览器的主要组成部分：用户界面，浏览器引擎，渲染引擎，网络请求模块，JS引擎，用户界面后端，数据层。各部分的作用为：用户界面：包括如地址栏，书签栏等内容构成了浏览器的用户界面，用来实现与用户之间的交互浏览器引擎：用于在渲染引擎和用户界面之间传递命令渲染引擎：当获取到请求的页面资源后，浏览器先解析HTML文档构建“结构树”，然后解析CSS文件，为“结构树”添加样式形成”渲染树“，接下来就是布局过程，为“渲染树”分配屏幕的位置坐标，最后进入绘制阶段，利用UI后端绘制出“渲染树”的每一个节点；另外，为了更好用户体验，浏览器引擎不会等到所有html解析完成后再去构建和布局render树。它是完成解析完一部分内容就显示一部分内容，于此同时还可能通过网络下载相关内容网络请求模块：实现网络请求以及数据接收JS引擎：负责解析JS代码UI后端：负责绘制基本的部件，在底层与操作系统进行交互数据存储：负责存储数据 浏览器页面渲染过程（及尽量避免重绘回流的操作）1 用户输入网址（假设是HTML页面，第一次访问，无缓存） 浏览器想服务器发出HTTP请求，服务器返回HTML文件（善用缓存，减少HTTP请求，减轻服务器压力） 浏览器载入HTML代码，获取CSS文件（CSS文件合并，减少HTTP请求） 载入&lt;body&gt;，开始渲染页面（CSS文件放在最上面，避免重复渲染 ） 浏览器发现一个&lt;img&gt;，向服务器发出请求，此时浏览器不会等到图片下载完，而是继续渲染后面的代码（图片文件合并，减少HTTP请求） 服务器返回图片文件，由于图片面积，影响界面中其他元素的排版，此时，浏览器需要重新渲染这部分代码（最好图片都设置尺寸，避免重新渲染） 浏览器发现一个包含js代码的&lt;script&gt;标签，会立即运行该js代码（script最好放在页面最下面） js执行命令：隐藏掉代码中某个div元素，此时浏览器不得不重新渲染这部分代码（页面初始化样式不要使用js控制） 如果某时刻，用户通过点击某个按钮修个这个页面样式（如换肤），请求新的CSS文件，此时发生回流，重新渲染页面 关于reflow和repaintreflow：某个样式发生改变影响页面的布局，发生回流；reflow几乎无法避免，如树目录的折叠展开效果都会引起reflowrepaint：改变某个元素的背景色，文字或边框颜色等不影响布局的属性，成为repaint；reflow的成本比repaint高； 引起reflow的情况（标准流内的元素发生形态上的改变） 改变窗囗大小 改变文字大小 添加/删除样式表 内容的改变，如用户在输入框中敲字 激活伪类，如:hover (IE里是一个兄弟结点的伪类被激活) 操作class属性 脚本操作DOM 计算offsetWidth和offsetHeight 设置style属性reflow是不可避免的，只能将reflow对性能的影响减到最小。 尽可能限制reflow的影响范围。需要改变元素的样式，不要通过父级元素影响子元素。最好直接加在子元素上。 通过设置style属性改变结点样式的话，每设置一次都会导致一次reflow。所以最好通过设置class的方式。 实现元素的动画，它的position属性应当设为fixed或absolute，这样不会影响其它元素的布局。 权衡速度的平滑。比如实现一个动画，以1个像素为单位移动这样最平滑，但reflow就会过于频繁，CPU很快就会被完全占用。如果以3个像素为单位移动就会好很多。 不要用tables布局的另一个原因就是tables中某个元素一旦触发reflow就会导致table里所有的其它元素reflow。在适合用table的场合，可以设置table-layout为auto或fixed，这样可以让table一行一行的渲染，这种做法也是为了限制reflow的影响范围。 很多情况下都会触发reflow，如果css里有expression，每次都会重新计算一遍。 减少不必要的 DOM 层级（DOM depth）。改变 DOM 树中的一级会导致所有层级的改变，上至根部，下至被改变节点的子节点。这导致大量时间耗费在执行 reflow 上面。 避免不必要的复杂的 CSS 选择器，尤其是后代选择器（descendant selectors），因为为了匹配选择器将耗费更多的 CPU 从输入url到加载完成过程]]></content>
      <tags>
        <tag>浏览器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo主题修改]]></title>
    <url>%2F2019%2F09%2F06%2Fhexo%E4%B8%BB%E9%A2%98%E4%BF%AE%E6%94%B9%2F</url>
    <content type="text"><![CDATA[修改Hexo主题及问题记录 昨晚试着将段时间搭建的hexo改一下主题，觉得NexT.Mist看起来挺简洁，挺喜欢这种风格的； 以下主要是一个索引，记录我搭建以及修改过程所参考的文章搭建博客 当时搭建博客主要参考的博文有： Hexo官方文档 hexo史上最全搭建教程 NexT.Mist主题参考的博文： next官方文档 Hexo的Next主题详细配置 修改主题过程遇到的一些小失误 hexo new page tag 创建标签页时报错： FATAL can not read a block mapping entry; a multiline key may not be an implicit key at line 70, column 1: … 错误 解决办法：_config.yml中配置项的冒号后面要用空格隔开，再跟内容 将Hexo设置首页不显示全文 方法：在主题配置文件_config.yml中找到auto_excerpt字段，将enable修改为true，可以实现首页显示文章预览；不过这 并不是Hexo推荐的方法；Hexo推荐在文章中使用&lt;!-- more --&gt;在more之前的内容会显现在首页的文章预览中，而more之后的内容可以在文章详情中显示 Hexo瞎折腾系列(4) - 站点首页不显示文章全文 中文乱码问题：将_config.yml的格式保存为UTF-8 hexo,部署博客到github和coding上，代码put上去了，但是访问博客内容却没更新？ 解决方法：我的是浏览器缓存问题，清除以下浏览器缓存就行了； 其他原因可以参考：hexo,部署博客到github和coding上，代码put上去了，但是访问博客内容却没更新？ 附上Hexo常用命令Hexo常用命令]]></content>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo问题记录]]></title>
    <url>%2F2019%2F07%2F16%2Fhexo%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[记录Hexo搭建过程遇到的一些问题问题一：4000端口被占用解决方法：1.可以用hexo server -p 5000 命令将端口修改为50002.可以在_config.yml内加上如下代码更改hexo-server运行时的端口号： server: port: 4001 compress: true header: true其中4001可以换成想要运行的端口号。参考链接: https://segmentfault.com/q/1010000008546859?_ea=1678427 问题二：出现错误如下：解决方法：打开根目录下的_config.yml文件，添加【图中xxx为自定义的名字】 注意缩进方式参考链接: https://www.cnblogs.com/fanbi/p/10174558.html Hexo搭建过程参考博文链接：https://blog.csdn.net/sinat_37781304/article/details/82729029https://blog.csdn.net/Hoshea_chx/article/details/78826689]]></content>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F07%2F15%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
